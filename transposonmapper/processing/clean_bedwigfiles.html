<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>transposonmapper.processing.clean_bedwigfiles API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>transposonmapper.processing.clean_bedwigfiles</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os, sys
from transposonmapper.properties.get_chromosome_position import chromosome_position
from transposonmapper.processing.chromosome_names_in_files import chromosome_name_bedfile, chromosome_name_wigfile



def cleanfiles(filepath=None, custom_header=None, split_chromosomes=False):
 
    &#34;&#34;&#34;  This script removes transposon insertions in .bed and .wig files that were mapped outside the chromosomes, creates consistent naming for chromosomes and change the header of files with custom headers.
    This code reads a .bed or .wig file and remove any insertions that were mapped outside a chromosome.
    Mapping of a read outside a chromosome can happen during the alignment and transposon mapping steps and means that the position of an insertions site of a read is larger than the length of the chromosome it is mapped to.
    This function creates a new file with the same name as the inputfile with the extension _clean.bed or _clean.wig.
    This is saved at the same location as the input file.
    In this _clean file the redundant insertions that were mapped outside the chromosome are removed.
    The lengths of the chromosomes are determined the python function &#39;chromosome_position&#39; which is part of the python module &#39;chromosome_and_gene_positions.py&#39;.
    This module gets the lengths of the chromosomes from a .gff file downloaded from SGD (https://www.yeastgenome.org/).
    Besides removing the reads outside the chromosomes, it also changes the names of the chromosomes to roman numerals and a custom header can be inputted (optional).
    Finally, the bed and wig files can be split up in separate files for each chromosome. These are placed in _chromosomesplit folder located at the location of the bed or wig file.
    @author: gregoryvanbeek
    Created on Fri Mar  5 15:39:53 2021

    Parameters
    ----------
    filepath : str
        File path of the wig or bed file to analyze
    custom_header : str
        String header to be included in the output file 
    split_chromosomes :  Bool (True/False)
        If true then there will be a folder created for each chromosome , otherwise 
        there will be a file containing all the info for all chromosomes. 
   

    Returns
    -------
    A file with the same basename as the filepath, and in the same location, with the extension : _clean.wig/_clean.bed
        

    &#34;&#34;&#34;
    
  
    ## checking input files 

    if filepath == None:
        sys.exit(0)
    else:
        assert os.path.isfile(filepath), &#39;File not found: %s&#39; % filepath

    ## setiing some variables 
    chr_length_dict = chromosome_position(None)[0]

    filepath_splitext = os.path.splitext(filepath)
    exten = filepath_splitext[1]



    num_roman = [&#39;I&#39;,&#39;II&#39;,&#39;III&#39;,&#39;IV&#39;,&#39;V&#39;,&#39;VI&#39;,&#39;VII&#39;,&#39;VIII&#39;,&#39;IX&#39;,&#39;X&#39;,&#39;XI&#39;,&#39;XII&#39;,&#39;XIII&#39;,&#39;XIV&#39;,&#39;XV&#39;,&#39;XVI&#39;]

    ## main processing 

    if exten == &#34;.bed&#34;:
        print(&#34;Bed file loaded %s&#34; % filepath)

        chrom_names_dict, chrom_start_line_dict, chrom_end_line_dict = chromosome_name_bedfile(filepath)

        with open(filepath, &#34;r&#34;) as f:
            lines = f.readlines()


        with open(filepath_splitext[0]+&#34;_clean.bed&#34;, &#34;w&#34;) as w:
            #write header
            if custom_header == None or custom_header == &#34;&#34;:
                w.write(lines[0])
            else:
                w.write(&#34;track name=&#34; + str(custom_header) + &#34; useScore=1\n&#34;)

            for chrom in num_roman:
                print(&#34;evaluating chromosome %s&#34; % chrom)

                for line in lines[chrom_start_line_dict.get(chrom): chrom_end_line_dict.get(chrom)+1]:
                    line_list = &#34; &#34;.join(line.strip(&#34;\n&#34;).split()).split(&#34; &#34;)
                    if int(line_list[2]) &gt; chr_length_dict.get(chrom) or int(line_list[1]) &lt; 0:
                        print(&#34;Line removed: %s&#34; % line)
                    else:
                        for romanname, chromname in chrom_names_dict.items():
                            if chromname == line_list[0].replace(&#34;chr&#34;,&#34;&#34;):
                                chrom_nameroman = romanname
                        w.write(&#34;chr&#34; + str(chrom_nameroman) + &#34; &#34; + str(line_list[1]) + &#34; &#34; + str(line_list[2]) + &#34; &#34; + str(line_list[3]) + &#34; &#34; + str(line_list[4]) + &#34;\n&#34;)

            
            for line in lines[chrom_end_line_dict.get(&#34;XVI&#34;)+1:]:
                line_list = &#34; &#34;.join(line.strip(&#34;\n&#34;).split()).split(&#34; &#34;)
                w.write(&#34;chrM&#34; + &#34; &#34; + str(line_list[1]) + &#34; &#34; + str(line_list[2]) + &#34; &#34; + str(line_list[3]) + &#34; &#34; + str(line_list[4]) + &#34;\n&#34;)


        if split_chromosomes == True:
            path = os.path.dirname(filepath)
            name = os.path.splitext(os.path.basename(filepath_splitext[0]+&#34;_clean.bed&#34;))[0]

            directoryname = os.path.join(path, name + &#39;_chromosomesplit&#39;)

            if not os.path.exists(directoryname):
                os.mkdir(directoryname)

            chromosome_names = [&#39;I&#39;,&#39;II&#39;,&#39;III&#39;,&#39;IV&#39;,&#39;V&#39;,&#39;VI&#39;,&#39;VII&#39;,&#39;VIII&#39;,&#39;IX&#39;,&#39;X&#39;,&#39;XI&#39;,&#39;XII&#39;,&#39;XIII&#39;,&#39;XIV&#39;,&#39;XV&#39;,&#39;XVI&#39;]

            chrom_names_dict, chrom_start_line_dict, chrom_end_line_dict = chromosome_name_bedfile(os.path.join(path, name+&#34;.bed&#34;))

            with open(os.path.join(path,name+&#34;.bed&#34;), &#39;r&#39;) as f:
                lines = f.readlines()
            header = lines[0]


            for chrom in chromosome_names:
                outputfile = os.path.join(directoryname, name + &#39;_&#39; + str(chrom) + &#39;.bed&#39;)
                with open(outputfile, &#39;w+&#39;) as f:
                    f.write(header)
                    for l in range(chrom_start_line_dict.get(chrom), chrom_end_line_dict.get(chrom)+1):
                        f.write(lines[l])

                outputfile = os.path.join(directoryname, name + &#39;_M.bed&#39;)
                with open(outputfile, &#39;w+&#39;) as f:
                    f.write(header)
                    for l in range(chrom_end_line_dict.get(chromosome_names[-1])+1, len(lines)):
                        f.write(lines[l])




    elif exten == &#34;.wig&#34;:
        print(&#34;Wig file loaded %s&#34; % filepath)

        chrom_names_dict, chrom_start_line_dict, chrom_end_line_dict = chromosome_name_wigfile(filepath)

        with open(filepath, &#39;r&#39;) as f:
            lines = f.readlines()

        with open(filepath_splitext[0]+&#34;_clean.wig&#34;, &#34;w&#34;) as w:
            #write header
            if custom_header == None or custom_header == &#34;&#34;:
                w.write(lines[0].replace(&#39;,&#39;,&#39;&#39;))
            else:
                w.write(&#34;track type=wiggle_0 maxheightPixels=60 name=&#34; + str(custom_header) + &#34;\n&#34;)

            for chrom in num_roman:
                print(&#34;evaluating chromosome %s&#34; % chrom)

                #replace chromosome names from reference genome with roman numerals
                chrom_headerline = lines[chrom_start_line_dict.get(chrom) - 1]
                chrom_nameline = chrom_headerline.split(&#34;=&#34;)[1].strip(&#34;\n&#34;).replace(&#34;chr&#34;,&#34;&#34;)
                for romanname, chromname in chrom_names_dict.items():
                    if chromname.replace(&#34;chr&#34;,&#34;&#34;) == chrom_nameline:
                        chrom_nameroman = romanname
                w.write(&#34;variablestep chrom=chr&#34; + str(chrom_nameroman) + &#34;\n&#34;) #write header for each chromosome
                for line in lines[chrom_start_line_dict.get(chrom): chrom_end_line_dict.get(chrom)]: #no &#39;+1&#39; in for loop, this is only for bed file
                    line_list = &#34; &#34;.join(line.strip(&#34;\n&#34;).split()).split(&#34; &#34;)
                    if int(line_list[0]) &gt; chr_length_dict.get(chrom) or int(line_list[0]) &lt; 0:
                        print(&#34;Line removed: %s&#34; % line)
                    else:
                        w.write(line)


            w.write(&#34;variablestep chrom=chrM\n&#34;)
            for line in lines[chrom_end_line_dict.get(&#34;XVI&#34;)+1:]:
                w.write(line)



        if split_chromosomes == True:
            path = os.path.dirname(filepath)
            name = os.path.splitext(os.path.basename(filepath_splitext[0]+&#34;_clean.wig&#34;))[0]

            directoryname = os.path.join(path, name + &#39;_chromosomesplit&#39;)

            if not os.path.exists(directoryname):
                os.mkdir(directoryname)

            chromosome_names = [&#39;I&#39;,&#39;II&#39;,&#39;III&#39;,&#39;IV&#39;,&#39;V&#39;,&#39;VI&#39;,&#39;VII&#39;,&#39;VIII&#39;,&#39;IX&#39;,&#39;X&#39;,&#39;XI&#39;,&#39;XII&#39;,&#39;XIII&#39;,&#39;XIV&#39;,&#39;XV&#39;,&#39;XVI&#39;,&#39;M&#39;]

            chrom_names_dict, chrom_start_line_dict, chrom_end_line_dict = chromosome_name_wigfile(os.path.join(path, name+&#34;.wig&#34;))

            with open(os.path.join(path,name+&#34;.wig&#34;), &#39;r&#39;) as f:
                lines = f.readlines()
            header = lines[0]


            for chrom in chromosome_names:
                outputfile = os.path.join(directoryname, name + &#39;_&#39; + str(chrom) + &#39;.wig&#39;)
                with open(outputfile, &#39;w+&#39;) as f:
                    f.write(header)
                    for l in range(chrom_start_line_dict.get(chrom)-1, chrom_end_line_dict.get(chrom)):
                        f.write(lines[l])

    else:
        print(&#34;Extension not recognized&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="transposonmapper.processing.clean_bedwigfiles.cleanfiles"><code class="name flex">
<span>def <span class="ident">cleanfiles</span></span>(<span>filepath=None, custom_header=None, split_chromosomes=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This script removes transposon insertions in .bed and .wig files that were mapped outside the chromosomes, creates consistent naming for chromosomes and change the header of files with custom headers.
This code reads a .bed or .wig file and remove any insertions that were mapped outside a chromosome.
Mapping of a read outside a chromosome can happen during the alignment and transposon mapping steps and means that the position of an insertions site of a read is larger than the length of the chromosome it is mapped to.
This function creates a new file with the same name as the inputfile with the extension _clean.bed or _clean.wig.
This is saved at the same location as the input file.
In this _clean file the redundant insertions that were mapped outside the chromosome are removed.
The lengths of the chromosomes are determined the python function 'chromosome_position' which is part of the python module 'chromosome_and_gene_positions.py'.
This module gets the lengths of the chromosomes from a .gff file downloaded from SGD (<a href="https://www.yeastgenome.org/">https://www.yeastgenome.org/</a>).
Besides removing the reads outside the chromosomes, it also changes the names of the chromosomes to roman numerals and a custom header can be inputted (optional).
Finally, the bed and wig files can be split up in separate files for each chromosome. These are placed in _chromosomesplit folder located at the location of the bed or wig file.
@author: gregoryvanbeek
Created on Fri Mar
5 15:39:53 2021</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code></dt>
<dd>File path of the wig or bed file to analyze</dd>
<dt><strong><code>custom_header</code></strong> :&ensp;<code>str</code></dt>
<dd>String header to be included in the output file</dd>
<dt><strong><code>split_chromosomes</code></strong> :&ensp;<code>Bool (True/False)</code></dt>
<dd>If true then there will be a folder created for each chromosome , otherwise
there will be a file containing all the info for all chromosomes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A file with the same basename as the filepath, and in the same location, with the extension : _clean.wig/_clean.bed</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanfiles(filepath=None, custom_header=None, split_chromosomes=False):
 
    &#34;&#34;&#34;  This script removes transposon insertions in .bed and .wig files that were mapped outside the chromosomes, creates consistent naming for chromosomes and change the header of files with custom headers.
    This code reads a .bed or .wig file and remove any insertions that were mapped outside a chromosome.
    Mapping of a read outside a chromosome can happen during the alignment and transposon mapping steps and means that the position of an insertions site of a read is larger than the length of the chromosome it is mapped to.
    This function creates a new file with the same name as the inputfile with the extension _clean.bed or _clean.wig.
    This is saved at the same location as the input file.
    In this _clean file the redundant insertions that were mapped outside the chromosome are removed.
    The lengths of the chromosomes are determined the python function &#39;chromosome_position&#39; which is part of the python module &#39;chromosome_and_gene_positions.py&#39;.
    This module gets the lengths of the chromosomes from a .gff file downloaded from SGD (https://www.yeastgenome.org/).
    Besides removing the reads outside the chromosomes, it also changes the names of the chromosomes to roman numerals and a custom header can be inputted (optional).
    Finally, the bed and wig files can be split up in separate files for each chromosome. These are placed in _chromosomesplit folder located at the location of the bed or wig file.
    @author: gregoryvanbeek
    Created on Fri Mar  5 15:39:53 2021

    Parameters
    ----------
    filepath : str
        File path of the wig or bed file to analyze
    custom_header : str
        String header to be included in the output file 
    split_chromosomes :  Bool (True/False)
        If true then there will be a folder created for each chromosome , otherwise 
        there will be a file containing all the info for all chromosomes. 
   

    Returns
    -------
    A file with the same basename as the filepath, and in the same location, with the extension : _clean.wig/_clean.bed
        

    &#34;&#34;&#34;
    
  
    ## checking input files 

    if filepath == None:
        sys.exit(0)
    else:
        assert os.path.isfile(filepath), &#39;File not found: %s&#39; % filepath

    ## setiing some variables 
    chr_length_dict = chromosome_position(None)[0]

    filepath_splitext = os.path.splitext(filepath)
    exten = filepath_splitext[1]



    num_roman = [&#39;I&#39;,&#39;II&#39;,&#39;III&#39;,&#39;IV&#39;,&#39;V&#39;,&#39;VI&#39;,&#39;VII&#39;,&#39;VIII&#39;,&#39;IX&#39;,&#39;X&#39;,&#39;XI&#39;,&#39;XII&#39;,&#39;XIII&#39;,&#39;XIV&#39;,&#39;XV&#39;,&#39;XVI&#39;]

    ## main processing 

    if exten == &#34;.bed&#34;:
        print(&#34;Bed file loaded %s&#34; % filepath)

        chrom_names_dict, chrom_start_line_dict, chrom_end_line_dict = chromosome_name_bedfile(filepath)

        with open(filepath, &#34;r&#34;) as f:
            lines = f.readlines()


        with open(filepath_splitext[0]+&#34;_clean.bed&#34;, &#34;w&#34;) as w:
            #write header
            if custom_header == None or custom_header == &#34;&#34;:
                w.write(lines[0])
            else:
                w.write(&#34;track name=&#34; + str(custom_header) + &#34; useScore=1\n&#34;)

            for chrom in num_roman:
                print(&#34;evaluating chromosome %s&#34; % chrom)

                for line in lines[chrom_start_line_dict.get(chrom): chrom_end_line_dict.get(chrom)+1]:
                    line_list = &#34; &#34;.join(line.strip(&#34;\n&#34;).split()).split(&#34; &#34;)
                    if int(line_list[2]) &gt; chr_length_dict.get(chrom) or int(line_list[1]) &lt; 0:
                        print(&#34;Line removed: %s&#34; % line)
                    else:
                        for romanname, chromname in chrom_names_dict.items():
                            if chromname == line_list[0].replace(&#34;chr&#34;,&#34;&#34;):
                                chrom_nameroman = romanname
                        w.write(&#34;chr&#34; + str(chrom_nameroman) + &#34; &#34; + str(line_list[1]) + &#34; &#34; + str(line_list[2]) + &#34; &#34; + str(line_list[3]) + &#34; &#34; + str(line_list[4]) + &#34;\n&#34;)

            
            for line in lines[chrom_end_line_dict.get(&#34;XVI&#34;)+1:]:
                line_list = &#34; &#34;.join(line.strip(&#34;\n&#34;).split()).split(&#34; &#34;)
                w.write(&#34;chrM&#34; + &#34; &#34; + str(line_list[1]) + &#34; &#34; + str(line_list[2]) + &#34; &#34; + str(line_list[3]) + &#34; &#34; + str(line_list[4]) + &#34;\n&#34;)


        if split_chromosomes == True:
            path = os.path.dirname(filepath)
            name = os.path.splitext(os.path.basename(filepath_splitext[0]+&#34;_clean.bed&#34;))[0]

            directoryname = os.path.join(path, name + &#39;_chromosomesplit&#39;)

            if not os.path.exists(directoryname):
                os.mkdir(directoryname)

            chromosome_names = [&#39;I&#39;,&#39;II&#39;,&#39;III&#39;,&#39;IV&#39;,&#39;V&#39;,&#39;VI&#39;,&#39;VII&#39;,&#39;VIII&#39;,&#39;IX&#39;,&#39;X&#39;,&#39;XI&#39;,&#39;XII&#39;,&#39;XIII&#39;,&#39;XIV&#39;,&#39;XV&#39;,&#39;XVI&#39;]

            chrom_names_dict, chrom_start_line_dict, chrom_end_line_dict = chromosome_name_bedfile(os.path.join(path, name+&#34;.bed&#34;))

            with open(os.path.join(path,name+&#34;.bed&#34;), &#39;r&#39;) as f:
                lines = f.readlines()
            header = lines[0]


            for chrom in chromosome_names:
                outputfile = os.path.join(directoryname, name + &#39;_&#39; + str(chrom) + &#39;.bed&#39;)
                with open(outputfile, &#39;w+&#39;) as f:
                    f.write(header)
                    for l in range(chrom_start_line_dict.get(chrom), chrom_end_line_dict.get(chrom)+1):
                        f.write(lines[l])

                outputfile = os.path.join(directoryname, name + &#39;_M.bed&#39;)
                with open(outputfile, &#39;w+&#39;) as f:
                    f.write(header)
                    for l in range(chrom_end_line_dict.get(chromosome_names[-1])+1, len(lines)):
                        f.write(lines[l])




    elif exten == &#34;.wig&#34;:
        print(&#34;Wig file loaded %s&#34; % filepath)

        chrom_names_dict, chrom_start_line_dict, chrom_end_line_dict = chromosome_name_wigfile(filepath)

        with open(filepath, &#39;r&#39;) as f:
            lines = f.readlines()

        with open(filepath_splitext[0]+&#34;_clean.wig&#34;, &#34;w&#34;) as w:
            #write header
            if custom_header == None or custom_header == &#34;&#34;:
                w.write(lines[0].replace(&#39;,&#39;,&#39;&#39;))
            else:
                w.write(&#34;track type=wiggle_0 maxheightPixels=60 name=&#34; + str(custom_header) + &#34;\n&#34;)

            for chrom in num_roman:
                print(&#34;evaluating chromosome %s&#34; % chrom)

                #replace chromosome names from reference genome with roman numerals
                chrom_headerline = lines[chrom_start_line_dict.get(chrom) - 1]
                chrom_nameline = chrom_headerline.split(&#34;=&#34;)[1].strip(&#34;\n&#34;).replace(&#34;chr&#34;,&#34;&#34;)
                for romanname, chromname in chrom_names_dict.items():
                    if chromname.replace(&#34;chr&#34;,&#34;&#34;) == chrom_nameline:
                        chrom_nameroman = romanname
                w.write(&#34;variablestep chrom=chr&#34; + str(chrom_nameroman) + &#34;\n&#34;) #write header for each chromosome
                for line in lines[chrom_start_line_dict.get(chrom): chrom_end_line_dict.get(chrom)]: #no &#39;+1&#39; in for loop, this is only for bed file
                    line_list = &#34; &#34;.join(line.strip(&#34;\n&#34;).split()).split(&#34; &#34;)
                    if int(line_list[0]) &gt; chr_length_dict.get(chrom) or int(line_list[0]) &lt; 0:
                        print(&#34;Line removed: %s&#34; % line)
                    else:
                        w.write(line)


            w.write(&#34;variablestep chrom=chrM\n&#34;)
            for line in lines[chrom_end_line_dict.get(&#34;XVI&#34;)+1:]:
                w.write(line)



        if split_chromosomes == True:
            path = os.path.dirname(filepath)
            name = os.path.splitext(os.path.basename(filepath_splitext[0]+&#34;_clean.wig&#34;))[0]

            directoryname = os.path.join(path, name + &#39;_chromosomesplit&#39;)

            if not os.path.exists(directoryname):
                os.mkdir(directoryname)

            chromosome_names = [&#39;I&#39;,&#39;II&#39;,&#39;III&#39;,&#39;IV&#39;,&#39;V&#39;,&#39;VI&#39;,&#39;VII&#39;,&#39;VIII&#39;,&#39;IX&#39;,&#39;X&#39;,&#39;XI&#39;,&#39;XII&#39;,&#39;XIII&#39;,&#39;XIV&#39;,&#39;XV&#39;,&#39;XVI&#39;,&#39;M&#39;]

            chrom_names_dict, chrom_start_line_dict, chrom_end_line_dict = chromosome_name_wigfile(os.path.join(path, name+&#34;.wig&#34;))

            with open(os.path.join(path,name+&#34;.wig&#34;), &#39;r&#39;) as f:
                lines = f.readlines()
            header = lines[0]


            for chrom in chromosome_names:
                outputfile = os.path.join(directoryname, name + &#39;_&#39; + str(chrom) + &#39;.wig&#39;)
                with open(outputfile, &#39;w+&#39;) as f:
                    f.write(header)
                    for l in range(chrom_start_line_dict.get(chrom)-1, chrom_end_line_dict.get(chrom)):
                        f.write(lines[l])

    else:
        print(&#34;Extension not recognized&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="transposonmapper.processing" href="index.html">transposonmapper.processing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="transposonmapper.processing.clean_bedwigfiles.cleanfiles" href="#transposonmapper.processing.clean_bedwigfiles.cleanfiles">cleanfiles</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>