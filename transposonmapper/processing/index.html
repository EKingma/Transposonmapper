<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>transposonmapper.processing API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>transposonmapper.processing</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .chromosome_names_in_files import chromosome_name_bedfile, chromosome_name_wigfile
from .clean_bedwigfiles import cleanfiles
from .essential_genes_names import list_known_essentials
from .transposonread_profileplot_genome import profile_genome
from .profileplot_genome_helpers import (summed_chr,counts_genome,length_genome,middle_chrom_pos,
binned_list)
from .genomicfeatures_dataframe import dna_features
from .dna_features_helpers import (input_region, read_wig_file, read_pergene_file,gene_location,
feature_position,intergenic_regions,checking_features,build_dataframe)

from .read_sgdfeatures import sgd_features


__all__ = [
    &#34;chromosome_name_bedfile&#34;,
    &#34;chromosome_name_wigfile&#34;,
    &#34;cleanfiles&#34;,
    &#34;list_known_essentials&#34;,
    &#34;summed_chr&#34;,&#34;counts_genome&#34;,
    &#34;length_genome&#34;,&#34;middle_chrom_pos&#34;,
&#34;binned_list&#34;, &#34;profile_genome&#34;,
&#34;dna_features&#34;, &#34;feature_position&#34;, 
&#34;input_region&#34;, &#34;read_wig_file&#34; , &#34;read_pergene_file&#34;,
&#34;sgd_features&#34;, &#34;gene_location&#34; ,&#34;intergenic_regions&#34;,
&#34;checking_features&#34;,&#34;build_dataframe&#34;
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="transposonmapper.processing.chromosome_names_in_files" href="chromosome_names_in_files.html">transposonmapper.processing.chromosome_names_in_files</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="transposonmapper.processing.clean_bedwigfiles" href="clean_bedwigfiles.html">transposonmapper.processing.clean_bedwigfiles</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="transposonmapper.processing.dna_features_helpers" href="dna_features_helpers.html">transposonmapper.processing.dna_features_helpers</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="transposonmapper.processing.essential_genes_names" href="essential_genes_names.html">transposonmapper.processing.essential_genes_names</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="transposonmapper.processing.genomicfeatures_dataframe" href="genomicfeatures_dataframe.html">transposonmapper.processing.genomicfeatures_dataframe</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="transposonmapper.processing.profileplot_genome_helpers" href="profileplot_genome_helpers.html">transposonmapper.processing.profileplot_genome_helpers</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="transposonmapper.processing.read_sgdfeatures" href="read_sgdfeatures.html">transposonmapper.processing.read_sgdfeatures</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="transposonmapper.processing.transposonread_profileplot_genome" href="transposonread_profileplot_genome.html">transposonmapper.processing.transposonread_profileplot_genome</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="transposonmapper.processing.binned_list"><code class="name flex">
<span>def <span class="ident">binned_list</span></span>(<span>allcounts_list, bar_width)</span>
</code></dt>
<dd>
<div class="desc"><p>A binned list for a histogram of the counts </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>allcounts_list</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Output of the counts_genome function</dd>
<dt><strong><code>bar_width</code></strong> :&ensp;<code>float </code></dt>
<dd>It could be a function of the length of the genome e.g. bar_width=l_genome/1000</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Binned list</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def binned_list(allcounts_list,bar_width):
    &#34;&#34;&#34;A binned list for a histogram of the counts 

    Parameters
    ----------
    allcounts_list : numpy.ndarray
        Output of the counts_genome function
    bar_width : float 
        It could be a function of the length of the genome e.g. bar_width=l_genome/1000

    Returns
    -------
    list
        Binned list 
    &#34;&#34;&#34;
    
    allcounts_binnedlist = []
    val_counter = 0
    sum_values = 0
    for n in range(len(allcounts_list)):
        if int(val_counter % bar_width) != 0:
            sum_values += allcounts_list[n]
        elif int(val_counter % bar_width) == 0:
            allcounts_binnedlist.append(sum_values)
            sum_values = 0
        val_counter += 1
    allcounts_binnedlist.append(sum_values)
    return allcounts_binnedlist</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.build_dataframe"><code class="name flex">
<span>def <span class="ident">build_dataframe</span></span>(<span>dna_dict, start_chr, end_chr, insrt_in_chrom_list, reads_in_chrom_list, genomicregions_list, chrom)</span>
</code></dt>
<dd>
<div class="desc"><p>Main function that build the big dataframe with all genes characteristics </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dna_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>1st output of the function intergenic_regions</dd>
<dt><strong><code>start_chr</code></strong> :&ensp;<code>int</code></dt>
<dd>2nd output of the function gene_location</dd>
<dt><strong><code>end_chr</code></strong> :&ensp;<code>int</code></dt>
<dd>3rd output of the function gene_location</dd>
<dt><strong><code>insrt_in_chrom_list</code></strong> :&ensp;<code>list</code></dt>
<dd>1st output of the function read_wig_file</dd>
<dt><strong><code>reads_in_chrom_list</code></strong> :&ensp;<code>list</code></dt>
<dd>2nd output of the function read_wig_file</dd>
<dt><strong><code>genomicregions_list</code></strong> :&ensp;<code>list</code></dt>
<dd>All the annotated genomic regions, 2nd output of the intergenic_regions function</dd>
<dt><strong><code>chrom</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the chromosome in roman where to extract the information.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>dataframe
- dna_df2: Dataframe containing information about the selected chromosome. This includes the following columns:
- Feature name
- Standard name of the feature
- Aliases of feature name (if any)
- Feature type (e.g. gene, telomere, centromere, etc. If None, this region is not defined)
- Chromosome
- Position of feature type in terms of bp relative to chromosome.
- Length of region in terms of basepairs
- Number of insertions in region
- Number of insertions in truncated region where truncated region is the region without the first and last 100bp.
- Number of reads in region
- Number of reads in truncated region.
- Number of reads per insertion (defined by Nreads/Ninsertions)
- Number of reads per insertion in truncated region (defined by Nreads_truncatedgene/Ninsertions_truncatedgene)
NOTE: truncated regions are only determined for genes. For the other regions the truncated region values are the same as the non-truncated region values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_dataframe(dna_dict,start_chr,end_chr,insrt_in_chrom_list,reads_in_chrom_list,genomicregions_list,chrom):
    &#34;&#34;&#34;Main function that build the big dataframe with all genes characteristics 

    Parameters
    ----------
    dna_dict : dict
        1st output of the function intergenic_regions
    start_chr : int
        2nd output of the function gene_location
    end_chr : int
        3rd output of the function gene_location
    insrt_in_chrom_list : list
        1st output of the function read_wig_file
    reads_in_chrom_list : list
        2nd output of the function read_wig_file
    genomicregions_list : list
        All the annotated genomic regions, 2nd output of the intergenic_regions function
    chrom : str
        Name of the chromosome in roman where to extract the information.

    Returns
    -------
    dataframe
    - dna_df2: Dataframe containing information about the selected chromosome. This includes the following columns:
        - Feature name
        - Standard name of the feature
        - Aliases of feature name (if any)
        - Feature type (e.g. gene, telomere, centromere, etc. If None, this region is not defined)
        - Chromosome
        - Position of feature type in terms of bp relative to chromosome.
        - Length of region in terms of basepairs
        - Number of insertions in region
        - Number of insertions in truncated region where truncated region is the region without the first and last 100bp.
        - Number of reads in region
        - Number of reads in truncated region.
        - Number of reads per insertion (defined by Nreads/Ninsertions)
        - Number of reads per insertion in truncated region (defined by Nreads_truncatedgene/Ninsertions_truncatedgene)
        NOTE: truncated regions are only determined for genes. For the other regions the truncated region values are the same as the non-truncated region values.


        
    &#34;&#34;&#34;

    _,essentials_file,gene_information_file=load_default_files()
    

    ## DETERMINE THE NUMBER OF TRANSPOSONS PER BP FOR EACH FEATURE

    reads_loc_list = [0] * len(dna_dict) # CONTAINS ALL READS JUST LIKE READS_IN_CHROM_LIST, BUT THIS LIST HAS THE SAME LENGTH AS THE NUMBER OF BP IN THE CHROMOSOME WHERE THE LOCATIONS WITH NO READS ARE FILLED WITH ZEROS
    i = 0
    for ins in insrt_in_chrom_list:
        reads_loc_list[ins] = reads_in_chrom_list[i]
        i += 1

    feature_NameAndType_list = []
    f_previous = dna_dict.get(start_chr)[0]
    f_type = dna_dict.get(start_chr)[1]
    N_reads = []
    N_reads_list_true=[]
    N_reads_list = []
    N_reads_truncatedgene_list = []
    N_insrt_truncatedgene_list = []
    N_insrt_list = []
    N_bp = 1
    N_bp_list = []
    f_start = 0
    f_end = 0
    f_pos_list = []
    i = 0
    for bp in dna_dict:
        f_current = dna_dict.get(bp)[0]
        if f_current == f_previous:
            f_type = dna_dict.get(bp)[1]
            f_end += 1
            N_bp += 1
            N_reads.append(reads_loc_list[i])
        elif (f_current != f_previous or (i+start_chr) == end_chr):# and not f_current.endswith(&#39;-A&#39;):
            feature_NameAndType_list.append([f_previous, f_type])
            N_reads_list.append(sum(N_reads))
            N_reads_list_true.append(np.array(N_reads,dtype=float))
            N_insrt_list.append(len([ins for ins in N_reads if not ins == 0]))
            if not f_type == None and f_type.startswith(&#39;Gene&#39;):
                N10percent = 100#int(len(N_reads) * 0.1) #TRUNCATED GENE DEFINITION
                N_reads_truncatedgene_list.append(sum(N_reads[N10percent:-N10percent]))
                N_insrt_truncatedgene_list.append(len([ins for ins in N_reads[N10percent:-N10percent] if not ins == 0]))
            else:
                N_reads_truncatedgene_list.append(sum(N_reads))
                N_insrt_truncatedgene_list.append(len([ins for ins in N_reads if not ins == 0]))

            N_bp_list.append(N_bp)
            N_reads = []
            N_bp = 1
            f_pos_list.append([f_start, f_end+f_start])
            f_start = f_start + f_end + 1
            f_end = 0
            f_previous = f_current
        i += 1

    N_reads_per_ins_list = []
    N_reads_per_ins_truncatedgene_list = []
    for i in range(len(N_reads_list)):
        if N_insrt_list[i] &lt; 5: # upper bound of low number of transposons 
            N_reads_per_ins_list.append(0)
            N_reads_per_ins_truncatedgene_list.append(0)
        elif N_insrt_truncatedgene_list[i] &lt; 5:
            N_reads_per_ins_list.append(N_reads_list[i]/(N_insrt_list[i]-1))
            N_reads_per_ins_truncatedgene_list.append(0)
        else:
            N_reads_per_ins_list.append(N_reads_list[i]/(N_insrt_list[i]-1))
            N_reads_per_ins_truncatedgene_list.append(N_reads_truncatedgene_list[i]/N_insrt_truncatedgene_list[i])


    #############get all essential genes together with their aliases##############
    with open(essentials_file, &#39;r&#39;) as f:
        essentials_temp_list = f.readlines()[1:]
    essentials_list = [essential.strip(&#39;\n&#39;) for essential in essentials_temp_list]
    del essentials_temp_list

    gene_alias_dict = gene_aliases(gene_information_file)[0]
    for key, val in gene_alias_dict.items():
        if key in essentials_list:
            for alias in val:
                essentials_list.append(alias)

    #ADD
    essentiality_list = []
    for feature in feature_NameAndType_list:
        if not feature[0] == &#34;noncoding&#34;:
            if feature[1] in genomicregions_list:
                essentiality_list.append(None)
            elif feature[0] in essentials_list:
                essentiality_list.append(True)
            else:
                essentiality_list.append(False)
        else:
            essentiality_list.append(None)

    

    feature_name_list = []
    feature_type_list = []
    feature_alias_list = []
    feature_standardname_list = []
    for feature_name in feature_NameAndType_list:
        feature_name_list.append(feature_name[0])
        feature_type_list.append(feature_name[1])
        if feature_name[1] != None and feature_name[1].startswith(&#39;Gene&#39;) and feature_name[0] in gene_alias_dict:
            if gene_alias_dict.get(feature_name[0])[0] == feature_name[0]:
                feature_standardname_list.append(feature_name[0])
                feature_alias_list.append(&#39;&#39;)
            else:
                if len(gene_alias_dict.get(feature_name[0])) &gt; 1:
                    feature_standardname_list.append(gene_alias_dict.get(feature_name[0])[0])
                    feature_alias_list.append(gene_alias_dict.get(feature_name[0])[1:])
                else:
                    feature_standardname_list.append(gene_alias_dict.get(feature_name[0])[0])
                    feature_alias_list.append(&#39;&#39;)
        else:
            feature_standardname_list.append(feature_name[0])
            feature_alias_list.append(&#39;&#39;)


    all_features = {&#39;Feature_name&#39;: feature_name_list,
                    &#39;Standard_name&#39;: feature_standardname_list,
                    &#39;Feature_alias&#39;:feature_alias_list,
                    &#39;Feature_type&#39;: feature_type_list,
                    &#39;Essentiality&#39;: essentiality_list,
                    &#39;Chromosome&#39;: [chrom]*len(feature_name_list),
                    &#39;Position&#39;: f_pos_list,
                    &#39;Nbasepairs&#39;:N_bp_list,
                    &#39;Ninsertions&#39;:N_insrt_list,
                    &#39;Ninsertions_truncatedgene&#39;:N_insrt_truncatedgene_list,
                    &#39;Nreads&#39;:N_reads_list,
                    &#39;Nreads_list&#39;:  N_reads_list_true,
                    &#39;Nreads_truncatedgene&#39;:N_reads_truncatedgene_list,
                    &#39;Nreadsperinsrt&#39;:N_reads_per_ins_list,
                    &#39;Nreadsperinsrt_truncatedgene&#39;:N_reads_per_ins_truncatedgene_list}


    dna_df2 = pd.DataFrame(all_features, columns = [column_name for column_name in all_features]) #search for feature using: dna_df2.loc[dna_df2[&#39;Feature&#39;] == &#39;CDC42&#39;]
    #CREATE NEW COLUMN WITH ALL DOMAINS OF THE GENE (IF PRESENT) AND ANOTHER COLUMN THAT INCLUDES LISTS OF THE BP POSITIONS OF THESE DOMAINS
    return dna_df2</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.checking_features"><code class="name flex">
<span>def <span class="ident">checking_features</span></span>(<span>feature_orf_dict, chrom, gene_position_dict, verbose)</span>
</code></dt>
<dd>
<div class="desc"><p>Checking input values </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature_orf_dict</code></strong> :&ensp;<code>dict </code></dt>
<dd>last output of the gene_location function</dd>
<dt><strong><code>chrom</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the chromosome in roman where to extract the information.</dd>
<dt><strong><code>gene_position_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>output of the read_pergene_file function</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool </code></dt>
<dd>If True it allows for warning messages</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checking_features(feature_orf_dict,chrom,gene_position_dict,verbose):
    &#34;&#34;&#34; Checking input values 

    Parameters
    ----------
    feature_orf_dict : dict 
        last output of the gene_location function 
    chrom : str
        Name of the chromosome in roman where to extract the information.
    gene_position_dict : dict
        output of the read_pergene_file function 
    verbose : bool 
        If True it allows for warning messages 
    &#34;&#34;&#34;

    ### TEST IF ELEMENTS IN FEATURE_ORF_DICT FOR SELECTED CHROMOSOME ARE THE SAME AS THE GENES IN GENE_POSITION_DICT BY CREATING THE DICTIONARY FEATURE_POSITION_DICT CONTAINING ALL THE GENES IN FEATURE_ORF_DICT WITH THEIR CORRESPONDING POSITION IN THE CHROMOSOME
    _,_,gene_information_file=load_default_files()

    gene_alias_dict = gene_aliases(gene_information_file)[0]
    orf_position_dict = {}
    for feature in feature_orf_dict:
        if feature_orf_dict.get(feature)[5] == chrom:
            if feature in gene_position_dict:
                orf_position_dict[feature] = [feature_orf_dict.get(feature)[6], feature_orf_dict.get(feature)[7]]
            else:
                for feature_alias in gene_alias_dict.get(feature):
                    if feature_alias in gene_position_dict:
                        orf_position_dict[feature_alias] = [feature_orf_dict.get(feature)[6], feature_orf_dict.get(feature)[7]]



    if sorted(orf_position_dict) == sorted(gene_position_dict):
        if verbose == True:
            print(&#39;Everything alright, just ignore me!&#39;)
        
    else:
        print(&#39;WARNING: Genes in feature_list are not the same as the genes in the gene_position_dict. Please check!&#39;)</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.chromosome_name_bedfile"><code class="name flex">
<span>def <span class="ident">chromosome_name_bedfile</span></span>(<span>bed_file)</span>
</code></dt>
<dd>
<div class="desc"><p>This function returns some properties of the chromosomes in a bed file.
Input can be either of two options:
The full path to a bed file after which the program opens the bed file, or
a list of the lines in the bed file. The latter requires to read the bed file before calling this function and input all lines in the bed file as a list. The function than does not open the bed file again.
Returns three dictionaries (in this order):
The first indicates the names of the chromosomes as used in the bed file (keys are roman numerals 1 to 16 and the values are the names used in the bed file).
The second is the start line in the bed file of each chromosome (keys are the roman numerals of the chromosome names and the values are the start lines in the bed file of the chromosome).
The third is the end line in the bed file of each chromosome (keys are the roman numerals of the chromosome names and the values are the start lines in the bed file of the chromosome)</p>
<p>CHANGE LINE 60 AND 71 TO AUTOMATICALLY RECOGNIZE THE MITOCHONDRIAL DNA NAME</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chromosome_name_bedfile(bed_file):
    &#39;&#39;&#39;This function returns some properties of the chromosomes in a bed file.
    Input can be either of two options:
        The full path to a bed file after which the program opens the bed file, or
        a list of the lines in the bed file. The latter requires to read the bed file before calling this function and input all lines in the bed file as a list. The function than does not open the bed file again.
    Returns three dictionaries (in this order):
        The first indicates the names of the chromosomes as used in the bed file (keys are roman numerals 1 to 16 and the values are the names used in the bed file).
        The second is the start line in the bed file of each chromosome (keys are the roman numerals of the chromosome names and the values are the start lines in the bed file of the chromosome).
        The third is the end line in the bed file of each chromosome (keys are the roman numerals of the chromosome names and the values are the start lines in the bed file of the chromosome)

    CHANGE LINE 60 AND 71 TO AUTOMATICALLY RECOGNIZE THE MITOCHONDRIAL DNA NAME
    &#39;&#39;&#39;
    
    
    if type(bed_file) is str:
        
        assert os.path.isfile(bed_file), &#34;ERROR: bed file not found&#34;
        with open(bed_file) as f:
            lines = f.readlines()
    elif type(bed_file) is list:
        lines = bed_file




    num_arabic = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]
    num_roman = [&#39;I&#39;,&#39;II&#39;,&#39;III&#39;,&#39;IV&#39;,&#39;V&#39;,&#39;VI&#39;,&#39;VII&#39;,&#39;VIII&#39;,&#39;IX&#39;,&#39;X&#39;,&#39;XI&#39;,&#39;XII&#39;,&#39;XIII&#39;,&#39;XIV&#39;,&#39;XV&#39;,&#39;XVI&#39;]
    roman_to_arabic_dict = {}
    index_counter = 0
    for rom in num_roman:
        roman_to_arabic_dict[rom] = num_arabic[index_counter]
        index_counter += 1

    chromosome_romannames_list = []
    for roman in roman_to_arabic_dict:
        chromosome_romannames_list.append(roman)




    chrom_names_dict = {}
    chrom_start_line_dict = {}
    chrom_end_line_dict = {}

    chrom_name_in_bed = &#39;&#39;
    chr_counter = 0
    line_counter = 0
    stop_loop = False
    while stop_loop is False:
        line = lines[line_counter]
        chrom_name_current = line.split(&#39; &#39;)[0].replace(&#39;chr&#39;,&#39;&#39;)
        if not chrom_name_current.startswith(&#39;track&#39;) and not chrom_name_current.startswith(&#39;M&#39;) and not chrom_name_current.startswith(&#39;ref|NC_001224|&#39;) and chr_counter &lt; 16: #SKIP HEADER AND MITOCHRONDRIAL CHROMOSOMES #and not chrom_name_current.startswith(&#39;M&#39;)
            if chrom_name_current != chrom_name_in_bed:
                chrom_names_dict[chromosome_romannames_list[chr_counter]] = chrom_name_current
                chrom_name_in_bed = chrom_name_current
#                print(&#39;Chromosome &#39;,chromosome_romannames_list[chr_counter], &#39;is &#39;,chrom_name_current)
                
                chrom_start_line_dict[chromosome_romannames_list[chr_counter]] = line_counter #GET START INDEX IN THE BED FILE OF THE CURENT CHROMOSOME
                if chr_counter != 0:
                    chrom_end_line_dict[chromosome_romannames_list[chr_counter-1]] = line_counter-1 #GET THE END INDEX IN THE BED OF THE PREVIOUS CHROMOSOME (SKIP FOR THE FIRST CHROMOSOME)

                chr_counter += 1

        elif chrom_name_current.startswith(&#39;M&#39;) or chrom_name_current.startswith(&#39;ref|NC_001224|&#39;):
            chrom_end_line_dict[chromosome_romannames_list[-1]] = line_counter-1 #GET THE END INDEX IN THE BED FILE FOR THE FINAL CHROMOSOME
            stop_loop = True
                
        line_counter += 1
        
    return(chrom_names_dict, chrom_start_line_dict, chrom_end_line_dict)</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.chromosome_name_wigfile"><code class="name flex">
<span>def <span class="ident">chromosome_name_wigfile</span></span>(<span>wig_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chromosome_name_wigfile(wig_file):

    if type(wig_file) is str:
      
        assert os.path.isfile(wig_file), &#34;ERROR: wig file not found&#34;
        with open(wig_file) as f:
            lines = f.readlines()
    elif type(wig_file) is list:
        lines = wig_file




    num_arabic = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]
    num_roman = [&#39;I&#39;,&#39;II&#39;,&#39;III&#39;,&#39;IV&#39;,&#39;V&#39;,&#39;VI&#39;,&#39;VII&#39;,&#39;VIII&#39;,&#39;IX&#39;,&#39;X&#39;,&#39;XI&#39;,&#39;XII&#39;,&#39;XIII&#39;,&#39;XIV&#39;,&#39;XV&#39;,&#39;XVI&#39;,&#39;M&#39;]
    roman_to_arabic_dict = {}
    index_counter = 0
    for rom in num_roman:
        roman_to_arabic_dict[rom] = num_arabic[index_counter]
        index_counter += 1

    chromosome_romannames_list = []
    for roman in roman_to_arabic_dict:
        chromosome_romannames_list.append(roman)





    chrom_names_dict = {}
    chrom_start_line_dict = {}
    chrom_end_line_dict = {}

    chr_counter = 0
    line_counter = 0
    chrom_line = &#39;variablestep&#39;
    for line in lines:
        line.strip(&#39;\n&#39;)
        line_split = line.split(&#39; &#39;)
        if line_split[0].lower() == chrom_line and chr_counter &lt; 17:
            chromosome_name = line_split[1].replace(&#39;chrom=chr&#39;,&#39;&#39;).strip(&#39;\n&#39;)
            chrom_names_dict[chromosome_romannames_list[chr_counter]] = chromosome_name
#            print(&#39;Chromosome &#39;,chromosome_romannames_list[chr_counter], &#39;is &#39;,chromosome_name)
            
            chrom_start_line_dict[chromosome_romannames_list[chr_counter]] = line_counter+1 #GET START INDEX IN THE BED FILE OF THE CURENT CHROMOSOME
            if chr_counter != 0:
                chrom_end_line_dict[chromosome_romannames_list[chr_counter-1]] = line_counter #GET THE END INDEX IN THE BED OF THE PREVIOUS CHROMOSOME (SKIP FOR THE FIRST CHROMOSOME)

            chr_counter += 1
        line_counter += 1

    chrom_end_line_dict[chromosome_romannames_list[chr_counter-1]] = len(lines)


    return(chrom_names_dict, chrom_start_line_dict, chrom_end_line_dict)</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.cleanfiles"><code class="name flex">
<span>def <span class="ident">cleanfiles</span></span>(<span>filepath=None, custom_header=None, split_chromosomes=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This script removes transposon insertions in .bed and .wig files that were mapped outside the chromosomes, creates consistent naming for chromosomes and change the header of files with custom headers.
This code reads a .bed or .wig file and remove any insertions that were mapped outside a chromosome.
Mapping of a read outside a chromosome can happen during the alignment and transposon mapping steps and means that the position of an insertions site of a read is larger than the length of the chromosome it is mapped to.
This function creates a new file with the same name as the inputfile with the extension _clean.bed or _clean.wig.
This is saved at the same location as the input file.
In this _clean file the redundant insertions that were mapped outside the chromosome are removed.
The lengths of the chromosomes are determined the python function 'chromosome_position' which is part of the python module 'chromosome_and_gene_positions.py'.
This module gets the lengths of the chromosomes from a .gff file downloaded from SGD (<a href="https://www.yeastgenome.org/">https://www.yeastgenome.org/</a>).
Besides removing the reads outside the chromosomes, it also changes the names of the chromosomes to roman numerals and a custom header can be inputted (optional).
Finally, the bed and wig files can be split up in separate files for each chromosome. These are placed in _chromosomesplit folder located at the location of the bed or wig file.
@author: gregoryvanbeek
Created on Fri Mar
5 15:39:53 2021</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code></dt>
<dd>File path of the wig or bed file to analyze</dd>
<dt><strong><code>custom_header</code></strong> :&ensp;<code>str</code></dt>
<dd>String header to be included in the output file</dd>
<dt><strong><code>split_chromosomes</code></strong> :&ensp;<code>Bool (True/False)</code></dt>
<dd>If true then there will be a folder created for each chromosome , otherwise
there will be a file containing all the info for all chromosomes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A file with the same basename as the filepath, and in the same location, with the extension : _clean.wig/_clean.bed</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanfiles(filepath=None, custom_header=None, split_chromosomes=False):
 
    &#34;&#34;&#34;  This script removes transposon insertions in .bed and .wig files that were mapped outside the chromosomes, creates consistent naming for chromosomes and change the header of files with custom headers.
    This code reads a .bed or .wig file and remove any insertions that were mapped outside a chromosome.
    Mapping of a read outside a chromosome can happen during the alignment and transposon mapping steps and means that the position of an insertions site of a read is larger than the length of the chromosome it is mapped to.
    This function creates a new file with the same name as the inputfile with the extension _clean.bed or _clean.wig.
    This is saved at the same location as the input file.
    In this _clean file the redundant insertions that were mapped outside the chromosome are removed.
    The lengths of the chromosomes are determined the python function &#39;chromosome_position&#39; which is part of the python module &#39;chromosome_and_gene_positions.py&#39;.
    This module gets the lengths of the chromosomes from a .gff file downloaded from SGD (https://www.yeastgenome.org/).
    Besides removing the reads outside the chromosomes, it also changes the names of the chromosomes to roman numerals and a custom header can be inputted (optional).
    Finally, the bed and wig files can be split up in separate files for each chromosome. These are placed in _chromosomesplit folder located at the location of the bed or wig file.
    @author: gregoryvanbeek
    Created on Fri Mar  5 15:39:53 2021

    Parameters
    ----------
    filepath : str
        File path of the wig or bed file to analyze
    custom_header : str
        String header to be included in the output file 
    split_chromosomes :  Bool (True/False)
        If true then there will be a folder created for each chromosome , otherwise 
        there will be a file containing all the info for all chromosomes. 
   

    Returns
    -------
    A file with the same basename as the filepath, and in the same location, with the extension : _clean.wig/_clean.bed
        

    &#34;&#34;&#34;
    
  
    ## checking input files 

    if filepath == None:
        sys.exit(0)
    else:
        assert os.path.isfile(filepath), &#39;File not found: %s&#39; % filepath

    ## setiing some variables 
    chr_length_dict = chromosome_position(None)[0]

    filepath_splitext = os.path.splitext(filepath)
    exten = filepath_splitext[1]



    num_roman = [&#39;I&#39;,&#39;II&#39;,&#39;III&#39;,&#39;IV&#39;,&#39;V&#39;,&#39;VI&#39;,&#39;VII&#39;,&#39;VIII&#39;,&#39;IX&#39;,&#39;X&#39;,&#39;XI&#39;,&#39;XII&#39;,&#39;XIII&#39;,&#39;XIV&#39;,&#39;XV&#39;,&#39;XVI&#39;]

    ## main processing 

    if exten == &#34;.bed&#34;:
        print(&#34;Bed file loaded %s&#34; % filepath)

        chrom_names_dict, chrom_start_line_dict, chrom_end_line_dict = chromosome_name_bedfile(filepath)

        with open(filepath, &#34;r&#34;) as f:
            lines = f.readlines()


        with open(filepath_splitext[0]+&#34;_clean.bed&#34;, &#34;w&#34;) as w:
            #write header
            if custom_header == None or custom_header == &#34;&#34;:
                w.write(lines[0])
            else:
                w.write(&#34;track name=&#34; + str(custom_header) + &#34; useScore=1\n&#34;)

            for chrom in num_roman:
                print(&#34;evaluating chromosome %s&#34; % chrom)

                for line in lines[chrom_start_line_dict.get(chrom): chrom_end_line_dict.get(chrom)+1]:
                    line_list = &#34; &#34;.join(line.strip(&#34;\n&#34;).split()).split(&#34; &#34;)
                    if int(line_list[2]) &gt; chr_length_dict.get(chrom) or int(line_list[1]) &lt; 0:
                        print(&#34;Line removed: %s&#34; % line)
                    else:
                        for romanname, chromname in chrom_names_dict.items():
                            if chromname == line_list[0].replace(&#34;chr&#34;,&#34;&#34;):
                                chrom_nameroman = romanname
                        w.write(&#34;chr&#34; + str(chrom_nameroman) + &#34; &#34; + str(line_list[1]) + &#34; &#34; + str(line_list[2]) + &#34; &#34; + str(line_list[3]) + &#34; &#34; + str(line_list[4]) + &#34;\n&#34;)

            
            for line in lines[chrom_end_line_dict.get(&#34;XVI&#34;)+1:]:
                line_list = &#34; &#34;.join(line.strip(&#34;\n&#34;).split()).split(&#34; &#34;)
                w.write(&#34;chrM&#34; + &#34; &#34; + str(line_list[1]) + &#34; &#34; + str(line_list[2]) + &#34; &#34; + str(line_list[3]) + &#34; &#34; + str(line_list[4]) + &#34;\n&#34;)


        if split_chromosomes == True:
            path = os.path.dirname(filepath)
            name = os.path.splitext(os.path.basename(filepath_splitext[0]+&#34;_clean.bed&#34;))[0]

            directoryname = os.path.join(path, name + &#39;_chromosomesplit&#39;)

            if not os.path.exists(directoryname):
                os.mkdir(directoryname)

            chromosome_names = [&#39;I&#39;,&#39;II&#39;,&#39;III&#39;,&#39;IV&#39;,&#39;V&#39;,&#39;VI&#39;,&#39;VII&#39;,&#39;VIII&#39;,&#39;IX&#39;,&#39;X&#39;,&#39;XI&#39;,&#39;XII&#39;,&#39;XIII&#39;,&#39;XIV&#39;,&#39;XV&#39;,&#39;XVI&#39;]

            chrom_names_dict, chrom_start_line_dict, chrom_end_line_dict = chromosome_name_bedfile(os.path.join(path, name+&#34;.bed&#34;))

            with open(os.path.join(path,name+&#34;.bed&#34;), &#39;r&#39;) as f:
                lines = f.readlines()
            header = lines[0]


            for chrom in chromosome_names:
                outputfile = os.path.join(directoryname, name + &#39;_&#39; + str(chrom) + &#39;.bed&#39;)
                with open(outputfile, &#39;w+&#39;) as f:
                    f.write(header)
                    for l in range(chrom_start_line_dict.get(chrom), chrom_end_line_dict.get(chrom)+1):
                        f.write(lines[l])

                outputfile = os.path.join(directoryname, name + &#39;_M.bed&#39;)
                with open(outputfile, &#39;w+&#39;) as f:
                    f.write(header)
                    for l in range(chrom_end_line_dict.get(chromosome_names[-1])+1, len(lines)):
                        f.write(lines[l])




    elif exten == &#34;.wig&#34;:
        print(&#34;Wig file loaded %s&#34; % filepath)

        chrom_names_dict, chrom_start_line_dict, chrom_end_line_dict = chromosome_name_wigfile(filepath)

        with open(filepath, &#39;r&#39;) as f:
            lines = f.readlines()

        with open(filepath_splitext[0]+&#34;_clean.wig&#34;, &#34;w&#34;) as w:
            #write header
            if custom_header == None or custom_header == &#34;&#34;:
                w.write(lines[0].replace(&#39;,&#39;,&#39;&#39;))
            else:
                w.write(&#34;track type=wiggle_0 maxheightPixels=60 name=&#34; + str(custom_header) + &#34;\n&#34;)

            for chrom in num_roman:
                print(&#34;evaluating chromosome %s&#34; % chrom)

                #replace chromosome names from reference genome with roman numerals
                chrom_headerline = lines[chrom_start_line_dict.get(chrom) - 1]
                chrom_nameline = chrom_headerline.split(&#34;=&#34;)[1].strip(&#34;\n&#34;).replace(&#34;chr&#34;,&#34;&#34;)
                for romanname, chromname in chrom_names_dict.items():
                    if chromname.replace(&#34;chr&#34;,&#34;&#34;) == chrom_nameline:
                        chrom_nameroman = romanname
                w.write(&#34;variablestep chrom=chr&#34; + str(chrom_nameroman) + &#34;\n&#34;) #write header for each chromosome
                for line in lines[chrom_start_line_dict.get(chrom): chrom_end_line_dict.get(chrom)]: #no &#39;+1&#39; in for loop, this is only for bed file
                    line_list = &#34; &#34;.join(line.strip(&#34;\n&#34;).split()).split(&#34; &#34;)
                    if int(line_list[0]) &gt; chr_length_dict.get(chrom) or int(line_list[0]) &lt; 0:
                        print(&#34;Line removed: %s&#34; % line)
                    else:
                        w.write(line)


            w.write(&#34;variablestep chrom=chrM\n&#34;)
            for line in lines[chrom_end_line_dict.get(&#34;XVI&#34;)+1:]:
                w.write(line)



        if split_chromosomes == True:
            path = os.path.dirname(filepath)
            name = os.path.splitext(os.path.basename(filepath_splitext[0]+&#34;_clean.wig&#34;))[0]

            directoryname = os.path.join(path, name + &#39;_chromosomesplit&#39;)

            if not os.path.exists(directoryname):
                os.mkdir(directoryname)

            chromosome_names = [&#39;I&#39;,&#39;II&#39;,&#39;III&#39;,&#39;IV&#39;,&#39;V&#39;,&#39;VI&#39;,&#39;VII&#39;,&#39;VIII&#39;,&#39;IX&#39;,&#39;X&#39;,&#39;XI&#39;,&#39;XII&#39;,&#39;XIII&#39;,&#39;XIV&#39;,&#39;XV&#39;,&#39;XVI&#39;,&#39;M&#39;]

            chrom_names_dict, chrom_start_line_dict, chrom_end_line_dict = chromosome_name_wigfile(os.path.join(path, name+&#34;.wig&#34;))

            with open(os.path.join(path,name+&#34;.wig&#34;), &#39;r&#39;) as f:
                lines = f.readlines()
            header = lines[0]


            for chrom in chromosome_names:
                outputfile = os.path.join(directoryname, name + &#39;_&#39; + str(chrom) + &#39;.wig&#39;)
                with open(outputfile, &#39;w+&#39;) as f:
                    f.write(header)
                    for l in range(chrom_start_line_dict.get(chrom)-1, chrom_end_line_dict.get(chrom)):
                        f.write(lines[l])

    else:
        print(&#34;Extension not recognized&#34;)</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.counts_genome"><code class="name flex">
<span>def <span class="ident">counts_genome</span></span>(<span>variable, bed_file, gff_file)</span>
</code></dt>
<dd>
<div class="desc"><p>Counts of reads or the transposons per chromosomes</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>variable</code></strong> :&ensp;<code>str</code></dt>
<dd>"transposons" or "reads"</dd>
<dt><strong><code>bed_file</code></strong> :&ensp;<code>str</code></dt>
<dd>absolute path of the location of the bedfile</dd>
<dt><strong><code>gff_file</code></strong> :&ensp;<code>str</code></dt>
<dd>absolute path of the location of the gff file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>An array of the length of the genome with the counts of each variable per location in the genome.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def counts_genome(variable,bed_file,gff_file):
    &#34;&#34;&#34;Counts of reads or the transposons per chromosomes

    Parameters
    ----------
    variable : str
        &#34;transposons&#34; or &#34;reads&#34;
    bed_file : str
        absolute path of the location of the bedfile
    gff_file : str
        absolute path of the location of the gff file 

    Returns
    -------
    numpy.ndarray
        An array of the length of the genome with the counts of each variable per location in the genome. 
    &#34;&#34;&#34;
    
    with open(bed_file) as f:
        lines = f.readlines()
    
    chrom_names_dict, chrom_start_index_dict, chrom_end_index_dict= chromosome_name_bedfile(bed_file)
    chr_length_dict, chr_start_pos_dict, chr_end_pos_dict = chromosome_position(gff_file)
    
    summed_chr_length_dict=summed_chr(chr_length_dict)
    
    l_genome=length_genome(chr_length_dict)

    allcounts_list = np.zeros(l_genome)
    if variable == &#34;transposons&#34;:
        for line in lines[chrom_start_index_dict.get(&#34;I&#34;):chrom_end_index_dict.get(&#34;XVI&#34;)+1]:
            line = line.strip(&#39;\n&#39;).split()
            chrom_name = [k for k,v in chrom_names_dict.items() if v == line[0].replace(&#34;chr&#34;,&#39;&#39;)][0]
            allcounts_list[summed_chr_length_dict.get(chrom_name) + int(line[1])-1] += 1
    elif variable == &#34;reads&#34;:
        for line in lines[chrom_start_index_dict.get(&#34;I&#34;):chrom_end_index_dict.get(&#34;XVI&#34;)+1]:
            line = line.strip(&#39;\n&#39;).split()
            chrom_name = [k for k,v in chrom_names_dict.items() if v == line[0].replace(&#34;chr&#34;,&#39;&#39;)][0]
            allcounts_list[summed_chr_length_dict.get(chrom_name) + int(line[1])-1] += (int(line[4])-100)/20
    return allcounts_list</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.dna_features"><code class="name flex">
<span>def <span class="ident">dna_features</span></span>(<span>region, wig_file, pergene_insertions_file, variable='reads', plotting=True, savefigure=False, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>This scripts takes a user defined genomic region (i.e. chromosome number, region or gene) and creates a dataframe including information about all genomic features in the chromosome (i.e. genes, nc-DNA etc.).
This can be used to determine the number of reads outside the genes to use this for normalization of the number of reads in the genes.
Output is a dataframe including major information about all genomic features and optionally a barplot indicating the number of transposons per genomic region.
A genomic region is here defined as a gene (separated as annotated essential and not essential), telomere, centromere, ars etc.
This can be used for identifying neutral regions (i.e. genomic regions that, if inhibited, do not influence the fitness of the cells).
This function can be used for normalizing the transposon insertions per gene using the neutral regions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>region</code></strong> :&ensp;<code>str</code></dt>
<dd>
<ul>
<li>Region: e.g. chromosome number (either a normal number between 1 and 16 or in roman numerals between I and XVI), a list like ['V', 0, 14790] which creates a barplot between basepair 0 and 14790) or a genename.</li>
</ul>
</dd>
<dt><strong><code>wig_file</code></strong> :&ensp;<code>str</code></dt>
<dd>absolute path for the wig file location</dd>
<dt><strong><code>pergene_insertions_file</code></strong> :&ensp;<code>str </code></dt>
<dd>asbsoulte path for the _pergene_insertions.txt file location</dd>
<dt><strong><code>variable</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>By default "reads". It could be "transposons"or "reads". This would be used for the plotting if True</dd>
<dt><strong><code>plotting</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not producing a bar plot with the reads/insertions per genomic location in the region, by default True</dd>
<dt><strong><code>savefigure</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not saving the plot in the same folder as the datafiles, by default False</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Determines how much textual feedback is given. When set to False, only warnings will be shown. By default True</dd>
</dl>
<h2 id="outputs">Outputs</h2>
<ul>
<li>
<p>dna_df2: Dataframe containing information about the selected chromosome. This includes the following columns:</p>
<h2 id="notes">Notes</h2>
</li>
</ul>
<p><strong>Date</strong>: 14-10-2020
<strong>Author</strong>: Gregory van Beek</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dna_features(region, wig_file, pergene_insertions_file, variable=&#34;reads&#34;, plotting=True, savefigure=False, verbose=True):
    &#34;&#34;&#34;This scripts takes a user defined genomic region (i.e. chromosome number, region or gene) and creates a dataframe including information about all genomic features in the chromosome (i.e. genes, nc-DNA etc.).
    This can be used to determine the number of reads outside the genes to use this for normalization of the number of reads in the genes.
    Output is a dataframe including major information about all genomic features and optionally a barplot indicating the number of transposons per genomic region.
    A genomic region is here defined as a gene (separated as annotated essential and not essential), telomere, centromere, ars etc.
    This can be used for identifying neutral regions (i.e. genomic regions that, if inhibited, do not influence the fitness of the cells).
    This function can be used for normalizing the transposon insertions per gene using the neutral regions.
    
              
    
    Parameters
    ----------
    region : str
        - Region: e.g. chromosome number (either a normal number between 1 and 16 or in roman numerals between I and XVI), a list like [&#39;V&#39;, 0, 14790] which creates a barplot between basepair 0 and 14790) or a genename.

    wig_file : str
        absolute path for the wig file location
    pergene_insertions_file : str 
        asbsoulte path for the _pergene_insertions.txt file location 
    variable : str, optional
        By default &#34;reads&#34;. It could be &#34;transposons&#34;or &#34;reads&#34;. This would be used for the plotting if True 
    plotting : bool, optional
        Whether or not producing a bar plot with the reads/insertions per genomic location in the region, by default True
    savefigure : bool, optional
        Whether or not saving the plot in the same folder as the datafiles, by default False
    verbose : bool, optional
        Determines how much textual feedback is given. When set to False, only warnings will be shown. By default True

    Outputs
    -------------------
    - dna_df2: Dataframe containing information about the selected chromosome. This includes the following columns:

        Notes
    ------------------

    __Date__: 14-10-2020
    __Author__: Gregory van Beek
    &#34;&#34;&#34;

    # If necessary, load default files
    gff_file, essentials_file, gene_information_file = load_default_files()
    sgd_features_file=load_sgd_tab()

    # Verify presence of files
    data_files = {
        &#34;gff3&#34;: gff_file,
        &#34;essentials&#34;: essentials_file,
        &#34;gene_names&#34;: gene_information_file,
        &#34;sgd_features&#34;: sgd_features_file
    }

    for filetype, file_path in data_files.items():
        assert file_path, f&#34;{filetype} not found at {file_path}&#34;


    variable = variable.lower()
    if plotting == True:
        create_plottitle = &#39;&#39;

# DETERMINE INPUTTED REGION

    roi_start,roi_end,region_type,chrom=input_region(region=region,verbose=verbose)

    

#READ WIG FILE FOR GETTING LOCATIONS OF ALL TN INSERTIONS

    insrt_in_chrom_list,reads_in_chrom_list=read_wig_file(wig_file=wig_file,chrom=chrom)


# READ PERGENE_INSERTIONS FILE FOR LOCATION OF ALL INSERTIONS PER EACH GENE.

    gene_position_dict=read_pergene_file(pergene_insertions_file=pergene_insertions_file,chrom=chrom)

# DETERMINE THE LOCATION GENOMIC FEATURES IN THE CURRENT CHROMOSOME AND STORE THIS IN A DICTIONARY

    dna_dict,start_chr,end_chr,len_chr,feature_orf_dict=gene_location(chrom,gene_position_dict,verbose)

## GET FEATURES FROM INTERGENIC REGIONS 

    dna_dict,genomicregions_list=intergenic_regions(chrom,start_chr,dna_dict)


    ### TEST IF ELEMENTS IN FEATURE_ORF_DICT FOR SELECTED CHROMOSOME ARE THE SAME AS THE GENES IN GENE_POSITION_DICT BY CREATING THE DICTIONARY FEATURE_POSITION_DICT CONTAINING ALL THE GENES IN FEATURE_ORF_DICT WITH THEIR CORRESPONDING POSITION IN THE CHROMOSOME
    checking_features(feature_orf_dict,chrom,gene_position_dict,verbose)

    dna_df2=build_dataframe(dna_dict,start_chr,end_chr,insrt_in_chrom_list,reads_in_chrom_list,genomicregions_list,chrom)

    #PRINT INFORMATION FOR THE SELECTED GENE
    if region_type == &#39;Gene&#39;:
        for region_info in dna_df2.itertuples():
            if region_info.Feature_name == region.upper() or region_info.Standard_name == region.upper():
                print(region_info)

    
    # CREATE BAR PLOT 
    dna_features_plot(chrom, dna_df2,roi_start,roi_end,len_chr,plotting,variable)

    if savefigure == True:
        file_dirname=pkg_resources.resource_filename(&#34;transposonmapper&#34;, &#34;data_files/&#34;)
        if variable == &#39;reads&#39;:
            saving_name = os.path.join(file_dirname,&#39;GenomicFeaturesReads_Barplot_Chrom&#39;+chrom+&#39;_NonNormalized&#39;)
        else:
            saving_name = os.path.join(file_dirname,&#39;GenomicFeaturesInsertions_Barplot_Chrom&#39;+chrom+&#39;_NonNormalized&#39;)
        plt.savefig(saving_name, orientation=&#39;landscape&#39;, dpi=200)
        plt.close()

    return(dna_df2)</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.feature_position"><code class="name flex">
<span>def <span class="ident">feature_position</span></span>(<span>feature_dict, chrom, start_chr, dna_dict, feature_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get features for every gene in the chromosome of interest </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>output of sgd_features(sgd_features_file)[i]</dd>
<dt><strong><code>chrom</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the chromosome in roman where to extract the information.</dd>
<dt><strong><code>start_chr</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>dna_dict</code></strong> :&ensp;<code>dict </code></dt>
<dd>first output of the gene_location function</dd>
<dt><strong><code>feature_type</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>[description], by default None</dd>
</dl>
<h2 id="output">Output</h2>
<p>dna_dict: dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def feature_position(feature_dict, chrom, start_chr, dna_dict, feature_type=None):
    &#34;&#34;&#34; Get features for every gene in the chromosome of interest 

    Parameters
    ----------
    feature_dict : dict
        output of sgd_features(sgd_features_file)[i]
    chrom : str
        Name of the chromosome in roman where to extract the information.
    start_chr : int
        [description]
    dna_dict : dict 
        first output of the gene_location function 
    feature_type : [type], optional
        [description], by default None

    Output
    ---------
    dna_dict: dict 

    &#34;&#34;&#34;
    
    position_dict = {}
    for feat in feature_dict:
        if feature_dict.get(feat)[5] == chrom:
#            if feat.startswith(&#34;TEL&#34;) and feat.endswith(&#39;L&#39;): #correct for the fact that telomeres at the end of a chromosome are stored in the reverse order.
            if int(feature_dict.get(feat)[6]) &gt; int(feature_dict.get(feat)[7]):
                position_dict[feat] = [feature_dict.get(feat)[5], feature_dict.get(feat)[7], feature_dict.get(feat)[6]]
            else:
                position_dict[feat] = [feature_dict.get(feat)[5], feature_dict.get(feat)[6], feature_dict.get(feat)[7]]


    for feat in position_dict:
        for bp in range(int(position_dict.get(feat)[1])+start_chr, int(position_dict.get(feat)[2])+start_chr):
            if dna_dict[bp] == [&#39;noncoding&#39;, None]:
                dna_dict[bp] = [feat, feature_type]


    return(dna_dict)</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.gene_location"><code class="name flex">
<span>def <span class="ident">gene_location</span></span>(<span>chrom, gene_position_dict, verbose)</span>
</code></dt>
<dd>
<div class="desc"><p>It gives structured information from the genes inside the chromosome of interest</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chrom</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the chromosome in roman where to extract the information.</dd>
<dt><strong><code>gene_position_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with info of the genes inside the chromosome . It is the output of the function
read_pergene_file</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool </code></dt>
<dd>Same as main function dna_features. If True allows for warning messages.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dna_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with info about genes encoded in the sgd features file</dd>
<dt><strong><code>start_ch</code></strong> :&ensp;<code>int</code></dt>
<dd>Integer indicating the genomic location of where the chromosome of interest starts</dd>
<dt><strong><code>end_chr</code></strong> :&ensp;<code>int </code></dt>
<dd>Integer indicating the genomic location of where the chromosome of interest ends</dd>
<dt><strong><code>len_chr</code></strong> :&ensp;<code>int</code></dt>
<dd>Length of the chromosome of interest</dd>
<dt><strong><code>feature_orf_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with info about genes in the chromosome of interest</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gene_location(chrom,gene_position_dict,verbose):
    &#34;&#34;&#34;It gives structured information from the genes inside the chromosome of interest

    Parameters
    ----------
    chrom : str
        Name of the chromosome in roman where to extract the information.
    gene_position_dict : dict
        Dictionary with info of the genes inside the chromosome . It is the output of the function
        read_pergene_file

    verbose : bool 
        Same as main function dna_features. If True allows for warning messages. 

    Returns
    -------
    dna_dict: dict
        Dictionary with info about genes encoded in the sgd features file 
    start_ch : int
        Integer indicating the genomic location of where the chromosome of interest starts
    end_chr: int 
        Integer indicating the genomic location of where the chromosome of interest ends
    len_chr: int
        Length of the chromosome of interest
    feature_orf_dict: dict
        Dictionary with info about genes in the chromosome of interest 
    &#34;&#34;&#34;

    gff_file,_,gene_information_file=load_default_files()
    sgd_features_file=load_sgd_tab()
    

    len_chr = chromosome_position(gff_file)[0].get(chrom)
    start_chr = chromosome_position(gff_file)[1].get(chrom)
    end_chr = chromosome_position(gff_file)[2].get(chrom)
    if verbose == True:
        print(&#39;Chromosome length = &#39;, len_chr)

    dna_dict = {} #for each bp in chromosome, determine whether it belongs to a noncoding or coding region
    for bp in range(start_chr, end_chr + 1): #initialize dna_dict with all basepair positions as [&#39;noncoding&#39;, None]
        dna_dict[bp] = [&#39;noncoding&#39;, None] #form is: [&#39;element_name&#39;, &#39;type&#39;]


    feature_orf_dict = sgd_features(sgd_features_file)[1]
    gene_alias_dict = gene_aliases(gene_information_file)[0]


    for gene in gene_position_dict:
        if gene in feature_orf_dict:
            if (not gene.endswith(&#34;-A&#34;) and not feature_orf_dict.get(gene)[1] == &#39;Verified&#39;) and (not gene.endswith(&#34;-B&#34;) and not feature_orf_dict.get(gene)[1] == &#39;Verified&#39;):
                for bp in range(gene_position_dict.get(gene)[1]+start_chr, gene_position_dict.get(gene)[2]+start_chr+1):
                    dna_dict[bp] = [gene, &#34;Gene; &#34;+feature_orf_dict.get(gene)[1]]
        else:
            gene_alias = [key for key, val in gene_alias_dict.items() if gene in val][0]
            for bp in range(gene_position_dict.get(gene)[1]+start_chr, gene_position_dict.get(gene)[2]+start_chr+1):
                dna_dict[bp] = [gene_alias, &#34;Gene; &#34;+feature_orf_dict.get(gene_alias)[1]]

    return dna_dict,start_chr,end_chr,len_chr,feature_orf_dict</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.input_region"><code class="name flex">
<span>def <span class="ident">input_region</span></span>(<span>region, verbose)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the region of interest for further processing </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>region</code></strong> :&ensp;<code>str, int</code> or <code>list</code></dt>
<dd>Enter chromosome as a number (or roman numeral) between 1 and 16 (I and XVI),
a list in the form ['chromosome number, start_position, end_position'] or a valid gene name.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>To allow warning messages.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>roi_start</code></strong> :&ensp;<code>NoneType, int </code></dt>
<dd>Describe the start of the genomic location if region=gene name , otherwise is a NoneType</dd>
<dt><strong><code>roi_end</code></strong> :&ensp;<code>NoneType, int </code></dt>
<dd>Describe the
end of the genomic location if region=gene name , otherwise is a NoneType</dd>
<dt><strong><code>region_type</code></strong> :&ensp;<code>str</code></dt>
<dd>It is either "Gene" or "Chromosome" depending on the region provided</dd>
<dt><strong><code>chrom</code></strong> :&ensp;<code>str</code></dt>
<dd>It is the name of the chromosome of the gene of interest if a gene name is provided as the region, otherwise
is the roman description of the chromosome of interest.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def input_region(region,verbose):
    &#34;&#34;&#34;Defines the region of interest for further processing 

    Parameters
    ----------
    region : str, int or list
        Enter chromosome as a number (or roman numeral) between 1 and 16 (I and XVI), 
        a list in the form [&#39;chromosome number, start_position, end_position&#39;] or a valid gene name.
    verbose : bool
        To allow warning messages. 
    

    Returns
    -------
    roi_start : NoneType, int 
        Describe the start of the genomic location if region=gene name , otherwise is a NoneType
    roi_end : NoneType, int 
        Describe the  end of the genomic location if region=gene name , otherwise is a NoneType

    region_type: str
        It is either &#34;Gene&#34; or &#34;Chromosome&#34; depending on the region provided
    chrom: str
        It is the name of the chromosome of the gene of interest if a gene name is provided as the region, otherwise
        is the roman description of the chromosome of interest. 
    &#34;&#34;&#34;
    
    gff_file,_,gene_information_file=load_default_files()

    warningmessage = &#34;WARNING: Specified chromosome or gene name not found. Enter chromosome as a number (or roman numeral) between 1 and 16 (I and XVI), a list in the form [&#39;chromosome number, start_position, end_position&#39;] or a valid gene name.&#34;

    
    if verbose == True:
        print(&#39;Selected region: &#39;, region)

    if type(region) == str:
        if region.upper() in chromosomename_roman_to_arabic()[1]:
            chrom = region.upper()
            roi_start = None
            roi_end = None
            region_type = &#39;Chromosome&#39;

        elif region.upper() in list_gene_names(gene_information_file):
            gene_pos_dict = gene_position(gff_file)
            region = region.upper()
            region_type=&#39;Gene&#39;
            if region in gene_pos_dict:
                region_pos = gene_pos_dict.get(region)
                chrom = region_pos[0]
                roi_start = int(region_pos[1])
                roi_end = int(region_pos[2])
            else:
                gene_alias_dict = gene_aliases(gene_information_file)[0]
                region_alias = [key for key, val in gene_alias_dict.items() if region in val]
                if not region_alias == [] and region_alias[0] in gene_pos_dict:
                    region_pos = gene_pos_dict.get(region_alias[0])
                    chrom = region_pos[0]
                    roi_start = int(region_pos[1])-100
                    roi_end = int(region_pos[2])+100
                    
                else:
                    print(warningmessage)
                    return()
            
            

        else:
            print(warningmessage)
            return()


    elif type(region) == list:
        if type(region[0]) == str:
            chrom = region[0].upper()
        elif type(region[0]) == int:
            if region[0] in chromosomename_roman_to_arabic()[0]:
                chrom = chromosomename_roman_to_arabic()[0].get(region[0])
        else:
            print(warningmessage)
            return()
        roi_start = region[1]
        roi_end = region[2]
        region_type = &#39;Chromosome&#39;


    elif type(region) == int:
        if region in chromosomename_roman_to_arabic()[0]:
            chrom = chromosomename_roman_to_arabic()[0].get(region)
            roi_start = None
            roi_end = None
        else:
            print(warningmessage)
            return()
        region_type = &#39;Chromosome&#39;


    else:
        print(warningmessage)
        return()
    
    return roi_start,roi_end,region_type,chrom</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.intergenic_regions"><code class="name flex">
<span>def <span class="ident">intergenic_regions</span></span>(<span>chrom, start_chr, dna_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Getting intergenic regions from chromosome of interest </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chrom</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the chromosome in roman where to extract the information.</dd>
<dt><strong><code>start_chr</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt>2nd output of the gene_location function</dt>
<dt><strong><code>dna_dict</code></strong> :&ensp;<code>dict </code></dt>
<dd>1st output of the gene_location function</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dna_dict_new</code></strong> :&ensp;<code>dict</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>genomicregions_list</code></strong> :&ensp;<code>list</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intergenic_regions(chrom,start_chr,dna_dict):
    &#34;&#34;&#34;Getting intergenic regions from chromosome of interest 

    Parameters
    ----------
    chrom : str
        Name of the chromosome in roman where to extract the information.
    start_chr : int
       2nd output of the gene_location function 
    dna_dict : dict 
        1st output of the gene_location function 

    Returns
    -------
    dna_dict_new : dict
        
    genomicregions_list: list

    
    &#34;&#34;&#34;


    sgd_features_file=load_sgd_tab()
    ## GET FEATURES FROM INTERGENIC REGIONS 

    genomicregions_list = sgd_features(sgd_features_file)[0]

    i = 2
    for genomicregion in genomicregions_list[1:]:
        dna_dict_new = feature_position(sgd_features(sgd_features_file)[i], chrom, start_chr, dna_dict, genomicregion)
        i += 1
    
    return dna_dict_new,genomicregions_list</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.length_genome"><code class="name flex">
<span>def <span class="ident">length_genome</span></span>(<span>chr_length_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Output the length of the genome in bp </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chr_length_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary describing the length of each chromosome.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The length of the genome</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def length_genome(chr_length_dict):
    
    &#34;&#34;&#34;Output the length of the genome in bp 

    Parameters
    ----------

    chr_length_dict : dict
        A dictionary describing the length of each chromosome. 

    Returns
    -------
    int
        The length of the genome
    &#34;&#34;&#34;
    
    chrom_list = [&#39;I&#39;, &#39;II&#39;, &#39;III&#39;, &#39;IV&#39;, &#39;V&#39;, &#39;VI&#39;, &#39;VII&#39;, &#39;VIII&#39;, &#39;IX&#39;, &#39;X&#39;, &#39;XI&#39;, &#39;XII&#39;, &#39;XIII&#39;, &#39;XIV&#39;, &#39;XV&#39;, &#39;XVI&#39;]

    l_genome = 0
    for chrom in chrom_list:
        l_genome += int(chr_length_dict.get(chrom))
   
    
    return l_genome</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.list_known_essentials"><code class="name flex">
<span>def <span class="ident">list_known_essentials</span></span>(<span>input_files=None, headerlines=3, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all known essential genes from two different files and combine them in one list.
Input is a list of of paths where files can be found with the known essential genes.
A default list is implemented using two files present in the same folder as this file.
It is expected that the files contain genes in a single column and nothing else.
An option can be set for the number of headerlines, which by default is set to 3.
The output is a list containing all the genes present in all files given in the input.</p>
<p>Note when using the default files: The length of the output list exceed the number of known essential genes as the list sometimes contains both the standard name and the systematic name of a gene.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_known_essentials(input_files = None, headerlines=3, verbose=True):
    &#39;&#39;&#39; Get all known essential genes from two different files and combine them in one list.
        Input is a list of of paths where files can be found with the known essential genes.
        A default list is implemented using two files present in the same folder as this file.
        It is expected that the files contain genes in a single column and nothing else.
        An option can be set for the number of headerlines, which by default is set to 3.
        The output is a list containing all the genes present in all files given in the input.
        
        Note when using the default files: The length of the output list exceed the number of known essential genes as the list sometimes contains both the standard name and the systematic name of a gene.
    &#39;&#39;&#39;
    
    if input_files == None:
        
        # If necessary, load default files
        gff_file, essential_genes_files, gene_name_file = load_default_files(
            gff_file=None, essentials_file=None, gene_names_file=None
        )

        # Verify presence of files
        data_files = {
            &#34;gff3&#34;: gff_file,
            &#34;essentials&#34;: essential_genes_files,
            &#34;gene_names&#34;: gene_name_file,
        }

        for filetype, file_path in data_files.items():
            assert file_path, f&#34;{filetype} not found at {file_path}&#34;
        
        input_files=essential_genes_files

    else:
        essential_genes_files = input_files


    known_essential_gene_list = []
    #making sure essential_genes_files is a list
    if type(essential_genes_files)!=list:
        essential_genes_files=[input_files]
        
    for files in essential_genes_files:
        if verbose == True:
            print(&#39;Reading file :&#39;,files)
        with open(files) as f:
            for header_lines in range(headerlines):
                next(f)
            for lines in f:
                known_essential_gene_list.append(lines.rstrip(&#39;\n&#39;))
                
    
    return(known_essential_gene_list)</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.middle_chrom_pos"><code class="name flex">
<span>def <span class="ident">middle_chrom_pos</span></span>(<span>chr_length_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the middle poit of each chromosome</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chr_length_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary describing the length of each chromosome.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list describing for each chromosome the middle point.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def middle_chrom_pos(chr_length_dict):
    &#34;&#34;&#34;Defines the middle poit of each chromosome

    Parameters
    ----------
    chr_length_dict : dict
        A dictionary describing the length of each chromosome. 

    Returns
    -------
    list
        A list describing for each chromosome the middle point. 
    &#34;&#34;&#34;
    
    summed_chr_length_dict=summed_chr(chr_length_dict)
    
    l_genome=length_genome(chr_length_dict)
    
    
    middle_chr_position = []
    c1 = summed_chr_length_dict.get(&#39;I&#39;)
    for c in summed_chr_length_dict:
        if not c == &#39;I&#39;:
            c2 = summed_chr_length_dict.get(c)
            middle_chr_position.append(c1 + (c2 - c1)/2)
            c1 = c2
            
    c2 = l_genome
    middle_chr_position.append(c1 + (c2 - c1)/2)
    
    return middle_chr_position</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.profile_genome"><code class="name flex">
<span>def <span class="ident">profile_genome</span></span>(<span>bed_file=None, variable='transposons', bar_width=None, savefig=False, showfig=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Created on Thu Mar 18 13:05:39 2021</p>
<p>@author: gregoryvanbeek
This function creates a bar plot along the entire genome.
The height of each bar represents the number of transposons or reads at the genomic position indicated on the x-axis.
The input is as follows:
- bed file
- variable ('transposons' or 'reads')
- bar_width
- savefig</p>
<p>The bar_width determines how many basepairs are put in one bin. Little basepairs per bin may be slow. Too many basepairs in one bin and possible low transposon areas might be obscured.
For this a list for essential genes is needed (used in 'list_known_essentials' function) and a .gff file is required (for the functions in 'chromosome_and_gene_positions.py') and a list for gene aliases (used in the function 'gene_aliases')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def profile_genome(bed_file=None, variable=&#34;transposons&#34;, bar_width=None, savefig=False,showfig=False):
    &#39;&#39;&#39;
    Created on Thu Mar 18 13:05:39 2021

    @author: gregoryvanbeek
    This function creates a bar plot along the entire genome.
    The height of each bar represents the number of transposons or reads at the genomic position indicated on the x-axis.
    The input is as follows:
        - bed file
        - variable (&#39;transposons&#39; or &#39;reads&#39;)
        - bar_width
        - savefig

    The bar_width determines how many basepairs are put in one bin. Little basepairs per bin may be slow. Too many basepairs in one bin and possible low transposon areas might be obscured.
    For this a list for essential genes is needed (used in &#39;list_known_essentials&#39; function) and a .gff file is required (for the functions in &#39;chromosome_and_gene_positions.py&#39;) and a list for gene aliases (used in the function &#39;gene_aliases&#39;)
    &#39;&#39;&#39;




    # If necessary, load default files
    gff_file, essential_file, gene_name_file = load_default_files(
        gff_file=None, essentials_file=None, gene_names_file=None
    )

    # Verify presence of files
    data_files = {
        &#34;gff3&#34;: gff_file,
        &#34;essentials&#34;: essential_file,
        &#34;gene_names&#34;: gene_name_file,
    }

    for filetype, file_path in data_files.items():
        assert file_path, f&#34;{filetype} not found at {file_path}&#34;


    chrom_list = [&#39;I&#39;, &#39;II&#39;, &#39;III&#39;, &#39;IV&#39;, &#39;V&#39;, &#39;VI&#39;, &#39;VII&#39;, &#39;VIII&#39;, &#39;IX&#39;, &#39;X&#39;, &#39;XI&#39;, &#39;XII&#39;, &#39;XIII&#39;, &#39;XIV&#39;, &#39;XV&#39;, &#39;XVI&#39;]
    
    chr_length_dict, chr_start_pos_dict, chr_end_pos_dict = chromosome_position(gff_file)
    
   
    summed_chr_length_dict=summed_chr(chr_length_dict)
    
       
    l_genome=length_genome(chr_length_dict)
    
    if bar_width == None:
        bar_width = l_genome/1000
    
    print(&#39;Genome length: &#39;, l_genome)
    
       
    middle_chr_position=middle_chrom_pos(chr_length_dict)

    gene_pos_dict = gene_position(gff_file)
    
    genes_currentchrom_pos_list = [k for k, v in gene_pos_dict.items()]
    
    genes_essential_list = list_known_essentials(essential_file)


    allcounts_list=counts_genome(variable,bed_file,gff_file)

    allcounts_binnedlist=binned_list(allcounts_list,bar_width)


    if bar_width == (l_genome/1000):
        allinsertionsites_list = np.linspace(0,l_genome,int(l_genome/bar_width+1))
    else:
        allinsertionsites_list = np.linspace(0,l_genome,int(l_genome/bar_width+2))


    ##########Ploting##############
    
    profile_genome_plot(bar_width,l_genome,allinsertionsites_list,allcounts_binnedlist,summed_chr_length_dict,
                         middle_chr_position,chrom_list,variable,genes_currentchrom_pos_list,gene_pos_dict)
    

    # saving the plot 
    if savefig == True and variable == &#34;transposons&#34;:
        savepath = os.path.splitext(bed_file)
        print(&#39;saving figure at %s&#39; % savepath[0]+&#39;_transposonplot_genome.png&#39;)
        plt.savefig(savepath[0]+&#39;_transposonplot_genome.png&#39;, dpi=400)
        plt.close()
    elif savefig == True and variable == &#34;reads&#34;:
        savepath = os.path.splitext(bed_file)
        print(&#39;saving figure at %s&#39; % savepath[0]+&#39;_readplot_genome.png&#39;)
        plt.savefig(savepath[0]+&#39;_readplot_genome.png&#39;, dpi=400)
        plt.close()
    if showfig==True:
        plt.show()
        
    return allinsertionsites_list,allcounts_binnedlist</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.read_pergene_file"><code class="name flex">
<span>def <span class="ident">read_pergene_file</span></span>(<span>pergene_insertions_file, chrom)</span>
</code></dt>
<dd>
<div class="desc"><p>Reading the pergene file , the information per gene , related to where it starts and ends in the genome. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pergene_insertions_file</code></strong> :&ensp;<code>str</code></dt>
<dd>absolute path of the per gene file location</dd>
<dt><strong><code>chrom</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the chromosome in roman where to extract the informatiion from the wigfile</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>gene_position_dict</code></strong> :&ensp;<code>dict </code></dt>
<dd>A dictionary describing the chromosome, start, and end location of every gene in the chromosome of interest.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_pergene_file(pergene_insertions_file,chrom):
    &#34;&#34;&#34;Reading the pergene file , the information per gene , related to where it starts and ends in the genome. 

    Parameters
    ----------
    pergene_insertions_file : str
        absolute path of the per gene file location
    chrom : str
        Name of the chromosome in roman where to extract the informatiion from the wigfile

    Returns
    -------
    gene_position_dict : dict 
        A dictionary describing the chromosome, start, and end location of every gene in the chromosome of interest. 
    &#34;&#34;&#34;

    with open(pergene_insertions_file) as f:
        lines = f.readlines()


    gene_position_dict = {}
    for line in lines[1:]:
        line_split = line.strip(&#39;\n&#39;).split(&#39;\t&#39;)


        if line_split[1] == chrom:
            genename = line_split[0]
            gene_chrom = line_split[1]
            gene_start = int(line_split[2])
            gene_end = int(line_split[3])

            gene_position_dict[genename] = [gene_chrom, gene_start, gene_end] #DICT CONTAINING ALL GENES WITHIN THE DEFINED CHROMOSOME INCLUDING ITS START AND END POSITION


            geneinserts_str = line_split[4].strip(&#39;[]&#39;)
            if not geneinserts_str == &#39;&#39;:
                geneinserts_list = [int(ins) for ins in geneinserts_str.split(&#39;,&#39;)]
            else:
                geneinserts_list = []


            genereads_str = line_split[5].strip(&#39;[]&#39;)
            if not genereads_str == &#39;&#39;:
                genereads_list = [int(read) for read in genereads_str.split(&#39;,&#39;)]
            else:
                genereads_list = []


            if len(geneinserts_list) != len(genereads_list):
                print(&#39;WARNING: %s has different number of reads compared with the number of inserts&#39; % genename )

    return gene_position_dict</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.read_wig_file"><code class="name flex">
<span>def <span class="ident">read_wig_file</span></span>(<span>wig_file, chrom)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the information in the wigfile related to the chromosome of interested</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wig_file</code></strong> :&ensp;<code>str</code></dt>
<dd>absolute path of the wigfile location</dd>
<dt><strong><code>chrom</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the chromosome in roman where to extract the informatiion from the wigfile</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>insrt_in_chrom_list</code></strong> :&ensp;<code>list </code></dt>
<dd>Genomic locations of transposon insertions in the given chromosome.</dd>
<dt><strong><code>reads_in_chrom_list</code></strong> :&ensp;<code>list</code></dt>
<dd>How many reads are in each of the genomic locations of the insertions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_wig_file(wig_file,chrom):
    &#34;&#34;&#34;Extract the information in the wigfile related to the chromosome of interested

    Parameters
    ----------
    wig_file : str
        absolute path of the wigfile location
    chrom : str
        Name of the chromosome in roman where to extract the informatiion from the wigfile

    Returns
    -------
    insrt_in_chrom_list : list 
        Genomic locations of transposon insertions in the given chromosome.
    reads_in_chrom_list: list
        How many reads are in each of the genomic locations of the insertions. 
    
    &#34;&#34;&#34;

    with open(wig_file, &#39;r&#39;) as f:
        lines = f.readlines()

    chrom_start_line_dict, chrom_end_line_dict = chromosome_name_wigfile(lines)[1:]

    insrt_in_chrom_list = []
    reads_in_chrom_list = []
    for l in lines[chrom_start_line_dict.get(chrom):chrom_end_line_dict.get(chrom)]:
        insrt_in_chrom_list.append(int(l.strip(&#39;\n&#39;).split(&#39; &#39;)[0]))
        reads_in_chrom_list.append(int(l.strip(&#39;\n&#39;).split(&#39; &#39;)[1]))
        
    return insrt_in_chrom_list,reads_in_chrom_list</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.sgd_features"><code class="name flex">
<span>def <span class="ident">sgd_features</span></span>(<span>filepath=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This function read the file SGD_features.tab and create a dictionary with useful info for processing</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>filepath of the sgd.tab file , by default None</dd>
</dl>
<h2 id="output">Output</h2>
<p>Output different dictionaries with info from the file. The most
useful is the 2nd output which contain the following information in this order:
key:
0. Feature name
value:
0. feature type (l[1])
1. feature qualifier (Verified or Dubious) (l[2])
2. Standard name (l[4])
3. Aliases (separated by '|') (l[5])
4. Parent feature name (typically 'chromosome &hellip;') (l[6])
5. Chromosome (l[8])
6. start coordinate (starting at 0 for each chromosome) (l[9])
7. end coordinate (starting at 0 for each chromosome) (l[10])</p>
<pre><code>    Created on Mon Sep  7 11:32:52 2020

    @author: gregoryvanbeek

    This file reads the SGD_features.txt file found at &lt;http://sgd-archive.yeastgenome.org/curation/chromosomal_feature/&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sgd_features(filepath=None):
    &#34;&#34;&#34;This function read the file SGD_features.tab and create a dictionary with useful info for processing

    Parameters
    ----------
    filepath : str, optional
        filepath of the sgd.tab file , by default None

    Output
    ----------
    Output different dictionaries with info from the file. The most 
    useful is the 2nd output which contain the following information in this order:
        key:
            0. Feature name
        value:
            0. feature type (l[1])
            1. feature qualifier (Verified or Dubious) (l[2])
            2. Standard name (l[4])
            3. Aliases (separated by &#39;|&#39;) (l[5])
            4. Parent feature name (typically &#39;chromosome ...&#39;) (l[6])
            5. Chromosome (l[8])
            6. start coordinate (starting at 0 for each chromosome) (l[9])
            7. end coordinate (starting at 0 for each chromosome) (l[10])
           
            Created on Mon Sep  7 11:32:52 2020

            @author: gregoryvanbeek

            This file reads the SGD_features.txt file found at http://sgd-archive.yeastgenome.org/curation/chromosomal_feature/
    &#34;&#34;&#34;

    if filepath == None:
        filepath=load_sgd_tab()

    arabic_to_roman_dict=chromosomename_roman_to_arabic()[0]
    
    with open(filepath) as f:
        lines = f.readlines()


    feature_list = []
    feature_orf_dict = {}
    feature_ars_dict = {}
    feature_telomere_dict = {}
    feature_ltr_dict = {}
    feature_centromere_dict = {}
    feature_Xelement_dict = {}
    feature_intron_dict = {}
    feature_ncrna_dict = {}
    feature_ncexon_dict = {}
    feature_trna_dict = {}
    feature_snorna_dict = {}
    feature_teg_dict = {}
    feature_5p_utrintron_dict = {}
    feature_mas_dict = {}
    feature_snrna_dict = {}
    feature_rrna_dict = {}
    feature_ets_dict = {}
    feature_its_dict = {}
    feature_oor_dict = {}
    feature_telrna_dict = {}
    
    for line in lines:
        l = line.strip(&#39;\n&#39;).split(&#39;\t&#39;)
        if not l[1] in feature_list:
            feature_list.append(l[1])

        if not l[8].endswith(&#39;micron&#39;) and not l[8] == &#39;&#39;:
            chromosome = arabic_to_roman_dict.get(int(l[8]))
            if l[1] == &#39;ORF&#39;:
                feature_orf_dict[l[3]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;ARS&#39;:
                feature_ars_dict[l[3]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;telomere&#39;:
                feature_telomere_dict[l[3]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;long_terminal_repeat&#39;:
                feature_ltr_dict[l[3]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;centromere&#39;:
                feature_centromere_dict[l[3]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;X_element&#39;:
                feature_Xelement_dict[l[3]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;intron&#39;:
                feature_intron_dict[l[6]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;ncRNA_gene&#39;:
                feature_ncrna_dict[l[3]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;noncoding_exon&#39;:
                feature_ncexon_dict[l[6]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;tRNA_gene&#39;:
                feature_trna_dict[l[3]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;snoRNA_gene&#39;:
                feature_snorna_dict[l[3]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;transposable_element_gene&#39;:
                feature_teg_dict[l[3]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;five_prime_UTR_intron&#39;:
                feature_5p_utrintron_dict[l[6]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;matrix_attachment_site&#39;:
                feature_mas_dict[l[3]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;snRNA_gene&#39;:
                feature_snrna_dict[l[3]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;rRNA_gene&#39;:
                feature_rrna_dict[l[3]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;external_transcribed_spacer_region&#39;:
                feature_ets_dict[l[6]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;internal_transcribed_spacer_region&#39;:
                feature_its_dict[l[6]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;origin_of_replication&#39;:
                feature_oor_dict[l[3]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]
            elif l[1] == &#39;telomerase_RNA_gene&#39;:
                feature_telrna_dict[l[3]] = [l[1], l[2], l[4], l[5], l[6], chromosome, l[9],l[10]]


    


    genomicregions_list = [&#39;ORF&#39;, &#39;ARS&#39;, &#39;Telomere&#39;, &#39;long_terminal_repeat&#39;,
                           &#39;Centromere&#39;, &#39;X_element&#39;, &#39;Intron&#39;, &#39;ncRNA_gene&#39;,
                           &#39;Noncoding_exon&#39;, &#39;tRNA_gene&#39;, &#39;snoRNA_gene&#39;,
                           &#39;transposable_element_gene&#39;, &#39;five_prime_UTR_intron&#39;,
                           &#39;matrix_attachment_site&#39;, &#39;snRNA_gene&#39;, &#39;rRNA_gene&#39;,
                           &#39;external_transcribed_spacer_region&#39;,
                           &#39;internal_transcribed_spacer_region&#39;,
                           &#39;origin_of_replication&#39;, &#39;telomerase_RNA_gene&#39;]


    return(genomicregions_list, feature_orf_dict, feature_ars_dict, feature_telomere_dict,
           feature_ltr_dict, feature_centromere_dict, feature_Xelement_dict, feature_intron_dict,
           feature_ncrna_dict, feature_ncexon_dict, feature_trna_dict,
           feature_snorna_dict, feature_teg_dict, feature_5p_utrintron_dict,
           feature_mas_dict, feature_snrna_dict, feature_rrna_dict,
           feature_ets_dict, feature_its_dict, feature_oor_dict,
           feature_telrna_dict)</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.summed_chr"><code class="name flex">
<span>def <span class="ident">summed_chr</span></span>(<span>chr_length_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a dictionary where each value is the cumulative sum of all bp in each chromosomes</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chr_length_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary describing the length of each chromosome.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary where each value corresponds to the cumulative sum of the previous chromosomes lengths.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summed_chr(chr_length_dict):
    &#34;&#34;&#34;Create a dictionary where each value is the cumulative sum of all bp in each chromosomes

    Parameters
    ----------
    chr_length_dict : dict
        A dictionary describing the length of each chromosome. 

    Returns
    -------
    dict
        A dictionary where each value corresponds to the cumulative sum of the previous chromosomes lengths. 
    &#34;&#34;&#34;
    
    chrom_list = [&#39;I&#39;, &#39;II&#39;, &#39;III&#39;, &#39;IV&#39;, &#39;V&#39;, &#39;VI&#39;, &#39;VII&#39;, &#39;VIII&#39;, &#39;IX&#39;, &#39;X&#39;, &#39;XI&#39;, &#39;XII&#39;, &#39;XIII&#39;, &#39;XIV&#39;, &#39;XV&#39;, &#39;XVI&#39;]
    summed_chr_length_dict = {}
    summed_chr_length = 0
    for c in chrom_list:
        summed_chr_length_dict[c] = summed_chr_length
        summed_chr_length += chr_length_dict.get(c)    
     
    return summed_chr_length_dict</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="transposonmapper" href="../index.html">transposonmapper</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="transposonmapper.processing.chromosome_names_in_files" href="chromosome_names_in_files.html">transposonmapper.processing.chromosome_names_in_files</a></code></li>
<li><code><a title="transposonmapper.processing.clean_bedwigfiles" href="clean_bedwigfiles.html">transposonmapper.processing.clean_bedwigfiles</a></code></li>
<li><code><a title="transposonmapper.processing.dna_features_helpers" href="dna_features_helpers.html">transposonmapper.processing.dna_features_helpers</a></code></li>
<li><code><a title="transposonmapper.processing.essential_genes_names" href="essential_genes_names.html">transposonmapper.processing.essential_genes_names</a></code></li>
<li><code><a title="transposonmapper.processing.genomicfeatures_dataframe" href="genomicfeatures_dataframe.html">transposonmapper.processing.genomicfeatures_dataframe</a></code></li>
<li><code><a title="transposonmapper.processing.profileplot_genome_helpers" href="profileplot_genome_helpers.html">transposonmapper.processing.profileplot_genome_helpers</a></code></li>
<li><code><a title="transposonmapper.processing.read_sgdfeatures" href="read_sgdfeatures.html">transposonmapper.processing.read_sgdfeatures</a></code></li>
<li><code><a title="transposonmapper.processing.transposonread_profileplot_genome" href="transposonread_profileplot_genome.html">transposonmapper.processing.transposonread_profileplot_genome</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="transposonmapper.processing.binned_list" href="#transposonmapper.processing.binned_list">binned_list</a></code></li>
<li><code><a title="transposonmapper.processing.build_dataframe" href="#transposonmapper.processing.build_dataframe">build_dataframe</a></code></li>
<li><code><a title="transposonmapper.processing.checking_features" href="#transposonmapper.processing.checking_features">checking_features</a></code></li>
<li><code><a title="transposonmapper.processing.chromosome_name_bedfile" href="#transposonmapper.processing.chromosome_name_bedfile">chromosome_name_bedfile</a></code></li>
<li><code><a title="transposonmapper.processing.chromosome_name_wigfile" href="#transposonmapper.processing.chromosome_name_wigfile">chromosome_name_wigfile</a></code></li>
<li><code><a title="transposonmapper.processing.cleanfiles" href="#transposonmapper.processing.cleanfiles">cleanfiles</a></code></li>
<li><code><a title="transposonmapper.processing.counts_genome" href="#transposonmapper.processing.counts_genome">counts_genome</a></code></li>
<li><code><a title="transposonmapper.processing.dna_features" href="#transposonmapper.processing.dna_features">dna_features</a></code></li>
<li><code><a title="transposonmapper.processing.feature_position" href="#transposonmapper.processing.feature_position">feature_position</a></code></li>
<li><code><a title="transposonmapper.processing.gene_location" href="#transposonmapper.processing.gene_location">gene_location</a></code></li>
<li><code><a title="transposonmapper.processing.input_region" href="#transposonmapper.processing.input_region">input_region</a></code></li>
<li><code><a title="transposonmapper.processing.intergenic_regions" href="#transposonmapper.processing.intergenic_regions">intergenic_regions</a></code></li>
<li><code><a title="transposonmapper.processing.length_genome" href="#transposonmapper.processing.length_genome">length_genome</a></code></li>
<li><code><a title="transposonmapper.processing.list_known_essentials" href="#transposonmapper.processing.list_known_essentials">list_known_essentials</a></code></li>
<li><code><a title="transposonmapper.processing.middle_chrom_pos" href="#transposonmapper.processing.middle_chrom_pos">middle_chrom_pos</a></code></li>
<li><code><a title="transposonmapper.processing.profile_genome" href="#transposonmapper.processing.profile_genome">profile_genome</a></code></li>
<li><code><a title="transposonmapper.processing.read_pergene_file" href="#transposonmapper.processing.read_pergene_file">read_pergene_file</a></code></li>
<li><code><a title="transposonmapper.processing.read_wig_file" href="#transposonmapper.processing.read_wig_file">read_wig_file</a></code></li>
<li><code><a title="transposonmapper.processing.sgd_features" href="#transposonmapper.processing.sgd_features">sgd_features</a></code></li>
<li><code><a title="transposonmapper.processing.summed_chr" href="#transposonmapper.processing.summed_chr">summed_chr</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>