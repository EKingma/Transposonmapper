<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>transposonmapper.processing.dna_features_helpers API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>transposonmapper.processing.dna_features_helpers</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import pkg_resources
import numpy as np
import pandas as pd 
from transposonmapper.utils import chromosomename_roman_to_arabic
from transposonmapper.importing import load_default_files,load_sgd_tab
from transposonmapper.properties import list_gene_names , gene_position, gene_aliases,chromosome_position
from transposonmapper.processing import chromosome_name_wigfile
from transposonmapper.processing.read_sgdfeatures import sgd_features   


def input_region(region,verbose):
    &#34;&#34;&#34;Defines the region of interest for further processing 

    Parameters
    ----------
    region : str, int or list
        Enter chromosome as a number (or roman numeral) between 1 and 16 (I and XVI), 
        a list in the form [&#39;chromosome number, start_position, end_position&#39;] or a valid gene name.
    verbose : bool
        To allow warning messages. 
    

    Returns
    -------
    roi_start : NoneType, int 
        Describe the start of the genomic location if region=gene name , otherwise is a NoneType
    roi_end : NoneType, int 
        Describe the  end of the genomic location if region=gene name , otherwise is a NoneType

    region_type: str
        It is either &#34;Gene&#34; or &#34;Chromosome&#34; depending on the region provided
    chrom: str
        It is the name of the chromosome of the gene of interest if a gene name is provided as the region, otherwise
        is the roman description of the chromosome of interest. 
    &#34;&#34;&#34;
    
    gff_file,_,gene_information_file=load_default_files()

    warningmessage = &#34;WARNING: Specified chromosome or gene name not found. Enter chromosome as a number (or roman numeral) between 1 and 16 (I and XVI), a list in the form [&#39;chromosome number, start_position, end_position&#39;] or a valid gene name.&#34;

    
    if verbose == True:
        print(&#39;Selected region: &#39;, region)

    if type(region) == str:
        if region.upper() in chromosomename_roman_to_arabic()[1]:
            chrom = region.upper()
            roi_start = None
            roi_end = None
            region_type = &#39;Chromosome&#39;

        elif region.upper() in list_gene_names(gene_information_file):
            gene_pos_dict = gene_position(gff_file)
            region = region.upper()
            region_type=&#39;Gene&#39;
            if region in gene_pos_dict:
                region_pos = gene_pos_dict.get(region)
                chrom = region_pos[0]
                roi_start = int(region_pos[1])
                roi_end = int(region_pos[2])
            else:
                gene_alias_dict = gene_aliases(gene_information_file)[0]
                region_alias = [key for key, val in gene_alias_dict.items() if region in val]
                if not region_alias == [] and region_alias[0] in gene_pos_dict:
                    region_pos = gene_pos_dict.get(region_alias[0])
                    chrom = region_pos[0]
                    roi_start = int(region_pos[1])-100
                    roi_end = int(region_pos[2])+100
                    
                else:
                    print(warningmessage)
                    return()
            
            

        else:
            print(warningmessage)
            return()


    elif type(region) == list:
        if type(region[0]) == str:
            chrom = region[0].upper()
        elif type(region[0]) == int:
            if region[0] in chromosomename_roman_to_arabic()[0]:
                chrom = chromosomename_roman_to_arabic()[0].get(region[0])
        else:
            print(warningmessage)
            return()
        roi_start = region[1]
        roi_end = region[2]
        region_type = &#39;Chromosome&#39;


    elif type(region) == int:
        if region in chromosomename_roman_to_arabic()[0]:
            chrom = chromosomename_roman_to_arabic()[0].get(region)
            roi_start = None
            roi_end = None
        else:
            print(warningmessage)
            return()
        region_type = &#39;Chromosome&#39;


    else:
        print(warningmessage)
        return()
    
    return roi_start,roi_end,region_type,chrom




def read_wig_file(wig_file,chrom):
    &#34;&#34;&#34;Extract the information in the wigfile related to the chromosome of interested

    Parameters
    ----------
    wig_file : str
        absolute path of the wigfile location
    chrom : str
        Name of the chromosome in roman where to extract the informatiion from the wigfile

    Returns
    -------
    insrt_in_chrom_list : list 
        Genomic locations of transposon insertions in the given chromosome.
    reads_in_chrom_list: list
        How many reads are in each of the genomic locations of the insertions. 
    
    &#34;&#34;&#34;

    with open(wig_file, &#39;r&#39;) as f:
        lines = f.readlines()

    chrom_start_line_dict, chrom_end_line_dict = chromosome_name_wigfile(lines)[1:]

    insrt_in_chrom_list = []
    reads_in_chrom_list = []
    for l in lines[chrom_start_line_dict.get(chrom):chrom_end_line_dict.get(chrom)]:
        insrt_in_chrom_list.append(int(l.strip(&#39;\n&#39;).split(&#39; &#39;)[0]))
        reads_in_chrom_list.append(int(l.strip(&#39;\n&#39;).split(&#39; &#39;)[1]))
        
    return insrt_in_chrom_list,reads_in_chrom_list


def read_pergene_file(pergene_insertions_file,chrom):
    &#34;&#34;&#34;Reading the pergene file , the information per gene , related to where it starts and ends in the genome. 

    Parameters
    ----------
    pergene_insertions_file : str
        absolute path of the per gene file location
    chrom : str
        Name of the chromosome in roman where to extract the informatiion from the wigfile

    Returns
    -------
    gene_position_dict : dict 
        A dictionary describing the chromosome, start, and end location of every gene in the chromosome of interest. 
    &#34;&#34;&#34;

    with open(pergene_insertions_file) as f:
        lines = f.readlines()


    gene_position_dict = {}
    for line in lines[1:]:
        line_split = line.strip(&#39;\n&#39;).split(&#39;\t&#39;)


        if line_split[1] == chrom:
            genename = line_split[0]
            gene_chrom = line_split[1]
            gene_start = int(line_split[2])
            gene_end = int(line_split[3])

            gene_position_dict[genename] = [gene_chrom, gene_start, gene_end] #DICT CONTAINING ALL GENES WITHIN THE DEFINED CHROMOSOME INCLUDING ITS START AND END POSITION


            geneinserts_str = line_split[4].strip(&#39;[]&#39;)
            if not geneinserts_str == &#39;&#39;:
                geneinserts_list = [int(ins) for ins in geneinserts_str.split(&#39;,&#39;)]
            else:
                geneinserts_list = []


            genereads_str = line_split[5].strip(&#39;[]&#39;)
            if not genereads_str == &#39;&#39;:
                genereads_list = [int(read) for read in genereads_str.split(&#39;,&#39;)]
            else:
                genereads_list = []


            if len(geneinserts_list) != len(genereads_list):
                print(&#39;WARNING: %s has different number of reads compared with the number of inserts&#39; % genename )

    return gene_position_dict


def gene_location(chrom,gene_position_dict,verbose):
    &#34;&#34;&#34;It gives structured information from the genes inside the chromosome of interest

    Parameters
    ----------
    chrom : str
        Name of the chromosome in roman where to extract the information.
    gene_position_dict : dict
        Dictionary with info of the genes inside the chromosome . It is the output of the function
        read_pergene_file

    verbose : bool 
        Same as main function dna_features. If True allows for warning messages. 

    Returns
    -------
    dna_dict: dict
        Dictionary with info about genes encoded in the sgd features file 
    start_ch : int
        Integer indicating the genomic location of where the chromosome of interest starts
    end_chr: int 
        Integer indicating the genomic location of where the chromosome of interest ends
    len_chr: int
        Length of the chromosome of interest
    feature_orf_dict: dict
        Dictionary with info about genes in the chromosome of interest 
    &#34;&#34;&#34;

    gff_file,_,gene_information_file=load_default_files()
    sgd_features_file=load_sgd_tab()
    

    len_chr = chromosome_position(gff_file)[0].get(chrom)
    start_chr = chromosome_position(gff_file)[1].get(chrom)
    end_chr = chromosome_position(gff_file)[2].get(chrom)
    if verbose == True:
        print(&#39;Chromosome length = &#39;, len_chr)

    dna_dict = {} #for each bp in chromosome, determine whether it belongs to a noncoding or coding region
    for bp in range(start_chr, end_chr + 1): #initialize dna_dict with all basepair positions as [&#39;noncoding&#39;, None]
        dna_dict[bp] = [&#39;noncoding&#39;, None] #form is: [&#39;element_name&#39;, &#39;type&#39;]


    feature_orf_dict = sgd_features(sgd_features_file)[1]
    gene_alias_dict = gene_aliases(gene_information_file)[0]


    for gene in gene_position_dict:
        if gene in feature_orf_dict:
            if (not gene.endswith(&#34;-A&#34;) and not feature_orf_dict.get(gene)[1] == &#39;Verified&#39;) and (not gene.endswith(&#34;-B&#34;) and not feature_orf_dict.get(gene)[1] == &#39;Verified&#39;):
                for bp in range(gene_position_dict.get(gene)[1]+start_chr, gene_position_dict.get(gene)[2]+start_chr+1):
                    dna_dict[bp] = [gene, &#34;Gene; &#34;+feature_orf_dict.get(gene)[1]]
        else:
            gene_alias = [key for key, val in gene_alias_dict.items() if gene in val][0]
            for bp in range(gene_position_dict.get(gene)[1]+start_chr, gene_position_dict.get(gene)[2]+start_chr+1):
                dna_dict[bp] = [gene_alias, &#34;Gene; &#34;+feature_orf_dict.get(gene_alias)[1]]

    return dna_dict,start_chr,end_chr,len_chr,feature_orf_dict


def feature_position(feature_dict, chrom, start_chr, dna_dict, feature_type=None):
    &#34;&#34;&#34; Get features for every gene in the chromosome of interest 

    Parameters
    ----------
    feature_dict : dict
        output of sgd_features(sgd_features_file)[i]
    chrom : str
        Name of the chromosome in roman where to extract the information.
    start_chr : int
        [description]
    dna_dict : dict 
        first output of the gene_location function 
    feature_type : [type], optional
        [description], by default None

    Output
    ---------
    dna_dict: dict 

    &#34;&#34;&#34;
    
    position_dict = {}
    for feat in feature_dict:
        if feature_dict.get(feat)[5] == chrom:
#            if feat.startswith(&#34;TEL&#34;) and feat.endswith(&#39;L&#39;): #correct for the fact that telomeres at the end of a chromosome are stored in the reverse order.
            if int(feature_dict.get(feat)[6]) &gt; int(feature_dict.get(feat)[7]):
                position_dict[feat] = [feature_dict.get(feat)[5], feature_dict.get(feat)[7], feature_dict.get(feat)[6]]
            else:
                position_dict[feat] = [feature_dict.get(feat)[5], feature_dict.get(feat)[6], feature_dict.get(feat)[7]]


    for feat in position_dict:
        for bp in range(int(position_dict.get(feat)[1])+start_chr, int(position_dict.get(feat)[2])+start_chr):
            if dna_dict[bp] == [&#39;noncoding&#39;, None]:
                dna_dict[bp] = [feat, feature_type]


    return(dna_dict)


def intergenic_regions(chrom,start_chr,dna_dict):
    &#34;&#34;&#34;Getting intergenic regions from chromosome of interest 

    Parameters
    ----------
    chrom : str
        Name of the chromosome in roman where to extract the information.
    start_chr : int
       2nd output of the gene_location function 
    dna_dict : dict 
        1st output of the gene_location function 

    Returns
    -------
    dna_dict_new : dict
        
    genomicregions_list: list

    
    &#34;&#34;&#34;


    sgd_features_file=load_sgd_tab()
    ## GET FEATURES FROM INTERGENIC REGIONS 

    genomicregions_list = sgd_features(sgd_features_file)[0]

    i = 2
    for genomicregion in genomicregions_list[1:]:
        dna_dict_new = feature_position(sgd_features(sgd_features_file)[i], chrom, start_chr, dna_dict, genomicregion)
        i += 1
    
    return dna_dict_new,genomicregions_list


def checking_features(feature_orf_dict,chrom,gene_position_dict,verbose):
    &#34;&#34;&#34; Checking input values 

    Parameters
    ----------
    feature_orf_dict : dict 
        last output of the gene_location function 
    chrom : str
        Name of the chromosome in roman where to extract the information.
    gene_position_dict : dict
        output of the read_pergene_file function 
    verbose : bool 
        If True it allows for warning messages 
    &#34;&#34;&#34;

    ### TEST IF ELEMENTS IN FEATURE_ORF_DICT FOR SELECTED CHROMOSOME ARE THE SAME AS THE GENES IN GENE_POSITION_DICT BY CREATING THE DICTIONARY FEATURE_POSITION_DICT CONTAINING ALL THE GENES IN FEATURE_ORF_DICT WITH THEIR CORRESPONDING POSITION IN THE CHROMOSOME
    _,_,gene_information_file=load_default_files()

    gene_alias_dict = gene_aliases(gene_information_file)[0]
    orf_position_dict = {}
    for feature in feature_orf_dict:
        if feature_orf_dict.get(feature)[5] == chrom:
            if feature in gene_position_dict:
                orf_position_dict[feature] = [feature_orf_dict.get(feature)[6], feature_orf_dict.get(feature)[7]]
            else:
                for feature_alias in gene_alias_dict.get(feature):
                    if feature_alias in gene_position_dict:
                        orf_position_dict[feature_alias] = [feature_orf_dict.get(feature)[6], feature_orf_dict.get(feature)[7]]



    if sorted(orf_position_dict) == sorted(gene_position_dict):
        if verbose == True:
            print(&#39;Everything alright, just ignore me!&#39;)
        
    else:
        print(&#39;WARNING: Genes in feature_list are not the same as the genes in the gene_position_dict. Please check!&#39;)

    
def build_dataframe(dna_dict,start_chr,end_chr,insrt_in_chrom_list,reads_in_chrom_list,genomicregions_list,chrom):
    &#34;&#34;&#34;Main function that build the big dataframe with all genes characteristics 

    Parameters
    ----------
    dna_dict : dict
        1st output of the function intergenic_regions
    start_chr : int
        2nd output of the function gene_location
    end_chr : int
        3rd output of the function gene_location
    insrt_in_chrom_list : list
        1st output of the function read_wig_file
    reads_in_chrom_list : list
        2nd output of the function read_wig_file
    genomicregions_list : list
        All the annotated genomic regions, 2nd output of the intergenic_regions function
    chrom : str
        Name of the chromosome in roman where to extract the information.

    Returns
    -------
    dataframe
    - dna_df2: Dataframe containing information about the selected chromosome. This includes the following columns:
        - Feature name
        - Standard name of the feature
        - Aliases of feature name (if any)
        - Feature type (e.g. gene, telomere, centromere, etc. If None, this region is not defined)
        - Chromosome
        - Position of feature type in terms of bp relative to chromosome.
        - Length of region in terms of basepairs
        - Number of insertions in region
        - Number of insertions in truncated region where truncated region is the region without the first and last 100bp.
        - Number of reads in region
        - Number of reads in truncated region.
        - Number of reads per insertion (defined by Nreads/Ninsertions)
        - Number of reads per insertion in truncated region (defined by Nreads_truncatedgene/Ninsertions_truncatedgene)
        NOTE: truncated regions are only determined for genes. For the other regions the truncated region values are the same as the non-truncated region values.


        
    &#34;&#34;&#34;

    _,essentials_file,gene_information_file=load_default_files()
    

    ## DETERMINE THE NUMBER OF TRANSPOSONS PER BP FOR EACH FEATURE

    reads_loc_list = [0] * len(dna_dict) # CONTAINS ALL READS JUST LIKE READS_IN_CHROM_LIST, BUT THIS LIST HAS THE SAME LENGTH AS THE NUMBER OF BP IN THE CHROMOSOME WHERE THE LOCATIONS WITH NO READS ARE FILLED WITH ZEROS
    i = 0
    for ins in insrt_in_chrom_list:
        reads_loc_list[ins] = reads_in_chrom_list[i]
        i += 1

    feature_NameAndType_list = []
    f_previous = dna_dict.get(start_chr)[0]
    f_type = dna_dict.get(start_chr)[1]
    N_reads = []
    N_reads_list_true=[]
    N_reads_list = []
    N_reads_truncatedgene_list = []
    N_insrt_truncatedgene_list = []
    N_insrt_list = []
    N_bp = 1
    N_bp_list = []
    f_start = 0
    f_end = 0
    f_pos_list = []
    i = 0
    for bp in dna_dict:
        f_current = dna_dict.get(bp)[0]
        if f_current == f_previous:
            f_type = dna_dict.get(bp)[1]
            f_end += 1
            N_bp += 1
            N_reads.append(reads_loc_list[i])
        elif (f_current != f_previous or (i+start_chr) == end_chr):# and not f_current.endswith(&#39;-A&#39;):
            feature_NameAndType_list.append([f_previous, f_type])
            N_reads_list.append(sum(N_reads))
            N_reads_list_true.append(np.array(N_reads,dtype=float))
            N_insrt_list.append(len([ins for ins in N_reads if not ins == 0]))
            if not f_type == None and f_type.startswith(&#39;Gene&#39;):
                N10percent = 100#int(len(N_reads) * 0.1) #TRUNCATED GENE DEFINITION
                N_reads_truncatedgene_list.append(sum(N_reads[N10percent:-N10percent]))
                N_insrt_truncatedgene_list.append(len([ins for ins in N_reads[N10percent:-N10percent] if not ins == 0]))
            else:
                N_reads_truncatedgene_list.append(sum(N_reads))
                N_insrt_truncatedgene_list.append(len([ins for ins in N_reads if not ins == 0]))

            N_bp_list.append(N_bp)
            N_reads = []
            N_bp = 1
            f_pos_list.append([f_start, f_end+f_start])
            f_start = f_start + f_end + 1
            f_end = 0
            f_previous = f_current
        i += 1

    N_reads_per_ins_list = []
    N_reads_per_ins_truncatedgene_list = []
    for i in range(len(N_reads_list)):
        if N_insrt_list[i] &lt; 5: # upper bound of low number of transposons 
            N_reads_per_ins_list.append(0)
            N_reads_per_ins_truncatedgene_list.append(0)
        elif N_insrt_truncatedgene_list[i] &lt; 5:
            N_reads_per_ins_list.append(N_reads_list[i]/(N_insrt_list[i]-1))
            N_reads_per_ins_truncatedgene_list.append(0)
        else:
            N_reads_per_ins_list.append(N_reads_list[i]/(N_insrt_list[i]-1))
            N_reads_per_ins_truncatedgene_list.append(N_reads_truncatedgene_list[i]/N_insrt_truncatedgene_list[i])


    #############get all essential genes together with their aliases##############
    with open(essentials_file, &#39;r&#39;) as f:
        essentials_temp_list = f.readlines()[1:]
    essentials_list = [essential.strip(&#39;\n&#39;) for essential in essentials_temp_list]
    del essentials_temp_list

    gene_alias_dict = gene_aliases(gene_information_file)[0]
    for key, val in gene_alias_dict.items():
        if key in essentials_list:
            for alias in val:
                essentials_list.append(alias)

    #ADD
    essentiality_list = []
    for feature in feature_NameAndType_list:
        if not feature[0] == &#34;noncoding&#34;:
            if feature[1] in genomicregions_list:
                essentiality_list.append(None)
            elif feature[0] in essentials_list:
                essentiality_list.append(True)
            else:
                essentiality_list.append(False)
        else:
            essentiality_list.append(None)

    

    feature_name_list = []
    feature_type_list = []
    feature_alias_list = []
    feature_standardname_list = []
    for feature_name in feature_NameAndType_list:
        feature_name_list.append(feature_name[0])
        feature_type_list.append(feature_name[1])
        if feature_name[1] != None and feature_name[1].startswith(&#39;Gene&#39;) and feature_name[0] in gene_alias_dict:
            if gene_alias_dict.get(feature_name[0])[0] == feature_name[0]:
                feature_standardname_list.append(feature_name[0])
                feature_alias_list.append(&#39;&#39;)
            else:
                if len(gene_alias_dict.get(feature_name[0])) &gt; 1:
                    feature_standardname_list.append(gene_alias_dict.get(feature_name[0])[0])
                    feature_alias_list.append(gene_alias_dict.get(feature_name[0])[1:])
                else:
                    feature_standardname_list.append(gene_alias_dict.get(feature_name[0])[0])
                    feature_alias_list.append(&#39;&#39;)
        else:
            feature_standardname_list.append(feature_name[0])
            feature_alias_list.append(&#39;&#39;)


    all_features = {&#39;Feature_name&#39;: feature_name_list,
                    &#39;Standard_name&#39;: feature_standardname_list,
                    &#39;Feature_alias&#39;:feature_alias_list,
                    &#39;Feature_type&#39;: feature_type_list,
                    &#39;Essentiality&#39;: essentiality_list,
                    &#39;Chromosome&#39;: [chrom]*len(feature_name_list),
                    &#39;Position&#39;: f_pos_list,
                    &#39;Nbasepairs&#39;:N_bp_list,
                    &#39;Ninsertions&#39;:N_insrt_list,
                    &#39;Ninsertions_truncatedgene&#39;:N_insrt_truncatedgene_list,
                    &#39;Nreads&#39;:N_reads_list,
                    &#39;Nreads_list&#39;:  N_reads_list_true,
                    &#39;Nreads_truncatedgene&#39;:N_reads_truncatedgene_list,
                    &#39;Nreadsperinsrt&#39;:N_reads_per_ins_list,
                    &#39;Nreadsperinsrt_truncatedgene&#39;:N_reads_per_ins_truncatedgene_list}


    dna_df2 = pd.DataFrame(all_features, columns = [column_name for column_name in all_features]) #search for feature using: dna_df2.loc[dna_df2[&#39;Feature&#39;] == &#39;CDC42&#39;]
    #CREATE NEW COLUMN WITH ALL DOMAINS OF THE GENE (IF PRESENT) AND ANOTHER COLUMN THAT INCLUDES LISTS OF THE BP POSITIONS OF THESE DOMAINS
    return dna_df2</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="transposonmapper.processing.dna_features_helpers.build_dataframe"><code class="name flex">
<span>def <span class="ident">build_dataframe</span></span>(<span>dna_dict, start_chr, end_chr, insrt_in_chrom_list, reads_in_chrom_list, genomicregions_list, chrom)</span>
</code></dt>
<dd>
<div class="desc"><p>Main function that build the big dataframe with all genes characteristics </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dna_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>1st output of the function intergenic_regions</dd>
<dt><strong><code>start_chr</code></strong> :&ensp;<code>int</code></dt>
<dd>2nd output of the function gene_location</dd>
<dt><strong><code>end_chr</code></strong> :&ensp;<code>int</code></dt>
<dd>3rd output of the function gene_location</dd>
<dt><strong><code>insrt_in_chrom_list</code></strong> :&ensp;<code>list</code></dt>
<dd>1st output of the function read_wig_file</dd>
<dt><strong><code>reads_in_chrom_list</code></strong> :&ensp;<code>list</code></dt>
<dd>2nd output of the function read_wig_file</dd>
<dt><strong><code>genomicregions_list</code></strong> :&ensp;<code>list</code></dt>
<dd>All the annotated genomic regions, 2nd output of the intergenic_regions function</dd>
<dt><strong><code>chrom</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the chromosome in roman where to extract the information.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>dataframe
- dna_df2: Dataframe containing information about the selected chromosome. This includes the following columns:
- Feature name
- Standard name of the feature
- Aliases of feature name (if any)
- Feature type (e.g. gene, telomere, centromere, etc. If None, this region is not defined)
- Chromosome
- Position of feature type in terms of bp relative to chromosome.
- Length of region in terms of basepairs
- Number of insertions in region
- Number of insertions in truncated region where truncated region is the region without the first and last 100bp.
- Number of reads in region
- Number of reads in truncated region.
- Number of reads per insertion (defined by Nreads/Ninsertions)
- Number of reads per insertion in truncated region (defined by Nreads_truncatedgene/Ninsertions_truncatedgene)
NOTE: truncated regions are only determined for genes. For the other regions the truncated region values are the same as the non-truncated region values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_dataframe(dna_dict,start_chr,end_chr,insrt_in_chrom_list,reads_in_chrom_list,genomicregions_list,chrom):
    &#34;&#34;&#34;Main function that build the big dataframe with all genes characteristics 

    Parameters
    ----------
    dna_dict : dict
        1st output of the function intergenic_regions
    start_chr : int
        2nd output of the function gene_location
    end_chr : int
        3rd output of the function gene_location
    insrt_in_chrom_list : list
        1st output of the function read_wig_file
    reads_in_chrom_list : list
        2nd output of the function read_wig_file
    genomicregions_list : list
        All the annotated genomic regions, 2nd output of the intergenic_regions function
    chrom : str
        Name of the chromosome in roman where to extract the information.

    Returns
    -------
    dataframe
    - dna_df2: Dataframe containing information about the selected chromosome. This includes the following columns:
        - Feature name
        - Standard name of the feature
        - Aliases of feature name (if any)
        - Feature type (e.g. gene, telomere, centromere, etc. If None, this region is not defined)
        - Chromosome
        - Position of feature type in terms of bp relative to chromosome.
        - Length of region in terms of basepairs
        - Number of insertions in region
        - Number of insertions in truncated region where truncated region is the region without the first and last 100bp.
        - Number of reads in region
        - Number of reads in truncated region.
        - Number of reads per insertion (defined by Nreads/Ninsertions)
        - Number of reads per insertion in truncated region (defined by Nreads_truncatedgene/Ninsertions_truncatedgene)
        NOTE: truncated regions are only determined for genes. For the other regions the truncated region values are the same as the non-truncated region values.


        
    &#34;&#34;&#34;

    _,essentials_file,gene_information_file=load_default_files()
    

    ## DETERMINE THE NUMBER OF TRANSPOSONS PER BP FOR EACH FEATURE

    reads_loc_list = [0] * len(dna_dict) # CONTAINS ALL READS JUST LIKE READS_IN_CHROM_LIST, BUT THIS LIST HAS THE SAME LENGTH AS THE NUMBER OF BP IN THE CHROMOSOME WHERE THE LOCATIONS WITH NO READS ARE FILLED WITH ZEROS
    i = 0
    for ins in insrt_in_chrom_list:
        reads_loc_list[ins] = reads_in_chrom_list[i]
        i += 1

    feature_NameAndType_list = []
    f_previous = dna_dict.get(start_chr)[0]
    f_type = dna_dict.get(start_chr)[1]
    N_reads = []
    N_reads_list_true=[]
    N_reads_list = []
    N_reads_truncatedgene_list = []
    N_insrt_truncatedgene_list = []
    N_insrt_list = []
    N_bp = 1
    N_bp_list = []
    f_start = 0
    f_end = 0
    f_pos_list = []
    i = 0
    for bp in dna_dict:
        f_current = dna_dict.get(bp)[0]
        if f_current == f_previous:
            f_type = dna_dict.get(bp)[1]
            f_end += 1
            N_bp += 1
            N_reads.append(reads_loc_list[i])
        elif (f_current != f_previous or (i+start_chr) == end_chr):# and not f_current.endswith(&#39;-A&#39;):
            feature_NameAndType_list.append([f_previous, f_type])
            N_reads_list.append(sum(N_reads))
            N_reads_list_true.append(np.array(N_reads,dtype=float))
            N_insrt_list.append(len([ins for ins in N_reads if not ins == 0]))
            if not f_type == None and f_type.startswith(&#39;Gene&#39;):
                N10percent = 100#int(len(N_reads) * 0.1) #TRUNCATED GENE DEFINITION
                N_reads_truncatedgene_list.append(sum(N_reads[N10percent:-N10percent]))
                N_insrt_truncatedgene_list.append(len([ins for ins in N_reads[N10percent:-N10percent] if not ins == 0]))
            else:
                N_reads_truncatedgene_list.append(sum(N_reads))
                N_insrt_truncatedgene_list.append(len([ins for ins in N_reads if not ins == 0]))

            N_bp_list.append(N_bp)
            N_reads = []
            N_bp = 1
            f_pos_list.append([f_start, f_end+f_start])
            f_start = f_start + f_end + 1
            f_end = 0
            f_previous = f_current
        i += 1

    N_reads_per_ins_list = []
    N_reads_per_ins_truncatedgene_list = []
    for i in range(len(N_reads_list)):
        if N_insrt_list[i] &lt; 5: # upper bound of low number of transposons 
            N_reads_per_ins_list.append(0)
            N_reads_per_ins_truncatedgene_list.append(0)
        elif N_insrt_truncatedgene_list[i] &lt; 5:
            N_reads_per_ins_list.append(N_reads_list[i]/(N_insrt_list[i]-1))
            N_reads_per_ins_truncatedgene_list.append(0)
        else:
            N_reads_per_ins_list.append(N_reads_list[i]/(N_insrt_list[i]-1))
            N_reads_per_ins_truncatedgene_list.append(N_reads_truncatedgene_list[i]/N_insrt_truncatedgene_list[i])


    #############get all essential genes together with their aliases##############
    with open(essentials_file, &#39;r&#39;) as f:
        essentials_temp_list = f.readlines()[1:]
    essentials_list = [essential.strip(&#39;\n&#39;) for essential in essentials_temp_list]
    del essentials_temp_list

    gene_alias_dict = gene_aliases(gene_information_file)[0]
    for key, val in gene_alias_dict.items():
        if key in essentials_list:
            for alias in val:
                essentials_list.append(alias)

    #ADD
    essentiality_list = []
    for feature in feature_NameAndType_list:
        if not feature[0] == &#34;noncoding&#34;:
            if feature[1] in genomicregions_list:
                essentiality_list.append(None)
            elif feature[0] in essentials_list:
                essentiality_list.append(True)
            else:
                essentiality_list.append(False)
        else:
            essentiality_list.append(None)

    

    feature_name_list = []
    feature_type_list = []
    feature_alias_list = []
    feature_standardname_list = []
    for feature_name in feature_NameAndType_list:
        feature_name_list.append(feature_name[0])
        feature_type_list.append(feature_name[1])
        if feature_name[1] != None and feature_name[1].startswith(&#39;Gene&#39;) and feature_name[0] in gene_alias_dict:
            if gene_alias_dict.get(feature_name[0])[0] == feature_name[0]:
                feature_standardname_list.append(feature_name[0])
                feature_alias_list.append(&#39;&#39;)
            else:
                if len(gene_alias_dict.get(feature_name[0])) &gt; 1:
                    feature_standardname_list.append(gene_alias_dict.get(feature_name[0])[0])
                    feature_alias_list.append(gene_alias_dict.get(feature_name[0])[1:])
                else:
                    feature_standardname_list.append(gene_alias_dict.get(feature_name[0])[0])
                    feature_alias_list.append(&#39;&#39;)
        else:
            feature_standardname_list.append(feature_name[0])
            feature_alias_list.append(&#39;&#39;)


    all_features = {&#39;Feature_name&#39;: feature_name_list,
                    &#39;Standard_name&#39;: feature_standardname_list,
                    &#39;Feature_alias&#39;:feature_alias_list,
                    &#39;Feature_type&#39;: feature_type_list,
                    &#39;Essentiality&#39;: essentiality_list,
                    &#39;Chromosome&#39;: [chrom]*len(feature_name_list),
                    &#39;Position&#39;: f_pos_list,
                    &#39;Nbasepairs&#39;:N_bp_list,
                    &#39;Ninsertions&#39;:N_insrt_list,
                    &#39;Ninsertions_truncatedgene&#39;:N_insrt_truncatedgene_list,
                    &#39;Nreads&#39;:N_reads_list,
                    &#39;Nreads_list&#39;:  N_reads_list_true,
                    &#39;Nreads_truncatedgene&#39;:N_reads_truncatedgene_list,
                    &#39;Nreadsperinsrt&#39;:N_reads_per_ins_list,
                    &#39;Nreadsperinsrt_truncatedgene&#39;:N_reads_per_ins_truncatedgene_list}


    dna_df2 = pd.DataFrame(all_features, columns = [column_name for column_name in all_features]) #search for feature using: dna_df2.loc[dna_df2[&#39;Feature&#39;] == &#39;CDC42&#39;]
    #CREATE NEW COLUMN WITH ALL DOMAINS OF THE GENE (IF PRESENT) AND ANOTHER COLUMN THAT INCLUDES LISTS OF THE BP POSITIONS OF THESE DOMAINS
    return dna_df2</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.dna_features_helpers.checking_features"><code class="name flex">
<span>def <span class="ident">checking_features</span></span>(<span>feature_orf_dict, chrom, gene_position_dict, verbose)</span>
</code></dt>
<dd>
<div class="desc"><p>Checking input values </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature_orf_dict</code></strong> :&ensp;<code>dict </code></dt>
<dd>last output of the gene_location function</dd>
<dt><strong><code>chrom</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the chromosome in roman where to extract the information.</dd>
<dt><strong><code>gene_position_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>output of the read_pergene_file function</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool </code></dt>
<dd>If True it allows for warning messages</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checking_features(feature_orf_dict,chrom,gene_position_dict,verbose):
    &#34;&#34;&#34; Checking input values 

    Parameters
    ----------
    feature_orf_dict : dict 
        last output of the gene_location function 
    chrom : str
        Name of the chromosome in roman where to extract the information.
    gene_position_dict : dict
        output of the read_pergene_file function 
    verbose : bool 
        If True it allows for warning messages 
    &#34;&#34;&#34;

    ### TEST IF ELEMENTS IN FEATURE_ORF_DICT FOR SELECTED CHROMOSOME ARE THE SAME AS THE GENES IN GENE_POSITION_DICT BY CREATING THE DICTIONARY FEATURE_POSITION_DICT CONTAINING ALL THE GENES IN FEATURE_ORF_DICT WITH THEIR CORRESPONDING POSITION IN THE CHROMOSOME
    _,_,gene_information_file=load_default_files()

    gene_alias_dict = gene_aliases(gene_information_file)[0]
    orf_position_dict = {}
    for feature in feature_orf_dict:
        if feature_orf_dict.get(feature)[5] == chrom:
            if feature in gene_position_dict:
                orf_position_dict[feature] = [feature_orf_dict.get(feature)[6], feature_orf_dict.get(feature)[7]]
            else:
                for feature_alias in gene_alias_dict.get(feature):
                    if feature_alias in gene_position_dict:
                        orf_position_dict[feature_alias] = [feature_orf_dict.get(feature)[6], feature_orf_dict.get(feature)[7]]



    if sorted(orf_position_dict) == sorted(gene_position_dict):
        if verbose == True:
            print(&#39;Everything alright, just ignore me!&#39;)
        
    else:
        print(&#39;WARNING: Genes in feature_list are not the same as the genes in the gene_position_dict. Please check!&#39;)</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.dna_features_helpers.feature_position"><code class="name flex">
<span>def <span class="ident">feature_position</span></span>(<span>feature_dict, chrom, start_chr, dna_dict, feature_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get features for every gene in the chromosome of interest </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>output of sgd_features(sgd_features_file)[i]</dd>
<dt><strong><code>chrom</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the chromosome in roman where to extract the information.</dd>
<dt><strong><code>start_chr</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>dna_dict</code></strong> :&ensp;<code>dict </code></dt>
<dd>first output of the gene_location function</dd>
<dt><strong><code>feature_type</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>[description], by default None</dd>
</dl>
<h2 id="output">Output</h2>
<p>dna_dict: dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def feature_position(feature_dict, chrom, start_chr, dna_dict, feature_type=None):
    &#34;&#34;&#34; Get features for every gene in the chromosome of interest 

    Parameters
    ----------
    feature_dict : dict
        output of sgd_features(sgd_features_file)[i]
    chrom : str
        Name of the chromosome in roman where to extract the information.
    start_chr : int
        [description]
    dna_dict : dict 
        first output of the gene_location function 
    feature_type : [type], optional
        [description], by default None

    Output
    ---------
    dna_dict: dict 

    &#34;&#34;&#34;
    
    position_dict = {}
    for feat in feature_dict:
        if feature_dict.get(feat)[5] == chrom:
#            if feat.startswith(&#34;TEL&#34;) and feat.endswith(&#39;L&#39;): #correct for the fact that telomeres at the end of a chromosome are stored in the reverse order.
            if int(feature_dict.get(feat)[6]) &gt; int(feature_dict.get(feat)[7]):
                position_dict[feat] = [feature_dict.get(feat)[5], feature_dict.get(feat)[7], feature_dict.get(feat)[6]]
            else:
                position_dict[feat] = [feature_dict.get(feat)[5], feature_dict.get(feat)[6], feature_dict.get(feat)[7]]


    for feat in position_dict:
        for bp in range(int(position_dict.get(feat)[1])+start_chr, int(position_dict.get(feat)[2])+start_chr):
            if dna_dict[bp] == [&#39;noncoding&#39;, None]:
                dna_dict[bp] = [feat, feature_type]


    return(dna_dict)</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.dna_features_helpers.gene_location"><code class="name flex">
<span>def <span class="ident">gene_location</span></span>(<span>chrom, gene_position_dict, verbose)</span>
</code></dt>
<dd>
<div class="desc"><p>It gives structured information from the genes inside the chromosome of interest</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chrom</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the chromosome in roman where to extract the information.</dd>
<dt><strong><code>gene_position_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with info of the genes inside the chromosome . It is the output of the function
read_pergene_file</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool </code></dt>
<dd>Same as main function dna_features. If True allows for warning messages.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dna_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with info about genes encoded in the sgd features file</dd>
<dt><strong><code>start_ch</code></strong> :&ensp;<code>int</code></dt>
<dd>Integer indicating the genomic location of where the chromosome of interest starts</dd>
<dt><strong><code>end_chr</code></strong> :&ensp;<code>int </code></dt>
<dd>Integer indicating the genomic location of where the chromosome of interest ends</dd>
<dt><strong><code>len_chr</code></strong> :&ensp;<code>int</code></dt>
<dd>Length of the chromosome of interest</dd>
<dt><strong><code>feature_orf_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with info about genes in the chromosome of interest</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gene_location(chrom,gene_position_dict,verbose):
    &#34;&#34;&#34;It gives structured information from the genes inside the chromosome of interest

    Parameters
    ----------
    chrom : str
        Name of the chromosome in roman where to extract the information.
    gene_position_dict : dict
        Dictionary with info of the genes inside the chromosome . It is the output of the function
        read_pergene_file

    verbose : bool 
        Same as main function dna_features. If True allows for warning messages. 

    Returns
    -------
    dna_dict: dict
        Dictionary with info about genes encoded in the sgd features file 
    start_ch : int
        Integer indicating the genomic location of where the chromosome of interest starts
    end_chr: int 
        Integer indicating the genomic location of where the chromosome of interest ends
    len_chr: int
        Length of the chromosome of interest
    feature_orf_dict: dict
        Dictionary with info about genes in the chromosome of interest 
    &#34;&#34;&#34;

    gff_file,_,gene_information_file=load_default_files()
    sgd_features_file=load_sgd_tab()
    

    len_chr = chromosome_position(gff_file)[0].get(chrom)
    start_chr = chromosome_position(gff_file)[1].get(chrom)
    end_chr = chromosome_position(gff_file)[2].get(chrom)
    if verbose == True:
        print(&#39;Chromosome length = &#39;, len_chr)

    dna_dict = {} #for each bp in chromosome, determine whether it belongs to a noncoding or coding region
    for bp in range(start_chr, end_chr + 1): #initialize dna_dict with all basepair positions as [&#39;noncoding&#39;, None]
        dna_dict[bp] = [&#39;noncoding&#39;, None] #form is: [&#39;element_name&#39;, &#39;type&#39;]


    feature_orf_dict = sgd_features(sgd_features_file)[1]
    gene_alias_dict = gene_aliases(gene_information_file)[0]


    for gene in gene_position_dict:
        if gene in feature_orf_dict:
            if (not gene.endswith(&#34;-A&#34;) and not feature_orf_dict.get(gene)[1] == &#39;Verified&#39;) and (not gene.endswith(&#34;-B&#34;) and not feature_orf_dict.get(gene)[1] == &#39;Verified&#39;):
                for bp in range(gene_position_dict.get(gene)[1]+start_chr, gene_position_dict.get(gene)[2]+start_chr+1):
                    dna_dict[bp] = [gene, &#34;Gene; &#34;+feature_orf_dict.get(gene)[1]]
        else:
            gene_alias = [key for key, val in gene_alias_dict.items() if gene in val][0]
            for bp in range(gene_position_dict.get(gene)[1]+start_chr, gene_position_dict.get(gene)[2]+start_chr+1):
                dna_dict[bp] = [gene_alias, &#34;Gene; &#34;+feature_orf_dict.get(gene_alias)[1]]

    return dna_dict,start_chr,end_chr,len_chr,feature_orf_dict</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.dna_features_helpers.input_region"><code class="name flex">
<span>def <span class="ident">input_region</span></span>(<span>region, verbose)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the region of interest for further processing </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>region</code></strong> :&ensp;<code>str, int</code> or <code>list</code></dt>
<dd>Enter chromosome as a number (or roman numeral) between 1 and 16 (I and XVI),
a list in the form ['chromosome number, start_position, end_position'] or a valid gene name.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>To allow warning messages.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>roi_start</code></strong> :&ensp;<code>NoneType, int </code></dt>
<dd>Describe the start of the genomic location if region=gene name , otherwise is a NoneType</dd>
<dt><strong><code>roi_end</code></strong> :&ensp;<code>NoneType, int </code></dt>
<dd>Describe the
end of the genomic location if region=gene name , otherwise is a NoneType</dd>
<dt><strong><code>region_type</code></strong> :&ensp;<code>str</code></dt>
<dd>It is either "Gene" or "Chromosome" depending on the region provided</dd>
<dt><strong><code>chrom</code></strong> :&ensp;<code>str</code></dt>
<dd>It is the name of the chromosome of the gene of interest if a gene name is provided as the region, otherwise
is the roman description of the chromosome of interest.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def input_region(region,verbose):
    &#34;&#34;&#34;Defines the region of interest for further processing 

    Parameters
    ----------
    region : str, int or list
        Enter chromosome as a number (or roman numeral) between 1 and 16 (I and XVI), 
        a list in the form [&#39;chromosome number, start_position, end_position&#39;] or a valid gene name.
    verbose : bool
        To allow warning messages. 
    

    Returns
    -------
    roi_start : NoneType, int 
        Describe the start of the genomic location if region=gene name , otherwise is a NoneType
    roi_end : NoneType, int 
        Describe the  end of the genomic location if region=gene name , otherwise is a NoneType

    region_type: str
        It is either &#34;Gene&#34; or &#34;Chromosome&#34; depending on the region provided
    chrom: str
        It is the name of the chromosome of the gene of interest if a gene name is provided as the region, otherwise
        is the roman description of the chromosome of interest. 
    &#34;&#34;&#34;
    
    gff_file,_,gene_information_file=load_default_files()

    warningmessage = &#34;WARNING: Specified chromosome or gene name not found. Enter chromosome as a number (or roman numeral) between 1 and 16 (I and XVI), a list in the form [&#39;chromosome number, start_position, end_position&#39;] or a valid gene name.&#34;

    
    if verbose == True:
        print(&#39;Selected region: &#39;, region)

    if type(region) == str:
        if region.upper() in chromosomename_roman_to_arabic()[1]:
            chrom = region.upper()
            roi_start = None
            roi_end = None
            region_type = &#39;Chromosome&#39;

        elif region.upper() in list_gene_names(gene_information_file):
            gene_pos_dict = gene_position(gff_file)
            region = region.upper()
            region_type=&#39;Gene&#39;
            if region in gene_pos_dict:
                region_pos = gene_pos_dict.get(region)
                chrom = region_pos[0]
                roi_start = int(region_pos[1])
                roi_end = int(region_pos[2])
            else:
                gene_alias_dict = gene_aliases(gene_information_file)[0]
                region_alias = [key for key, val in gene_alias_dict.items() if region in val]
                if not region_alias == [] and region_alias[0] in gene_pos_dict:
                    region_pos = gene_pos_dict.get(region_alias[0])
                    chrom = region_pos[0]
                    roi_start = int(region_pos[1])-100
                    roi_end = int(region_pos[2])+100
                    
                else:
                    print(warningmessage)
                    return()
            
            

        else:
            print(warningmessage)
            return()


    elif type(region) == list:
        if type(region[0]) == str:
            chrom = region[0].upper()
        elif type(region[0]) == int:
            if region[0] in chromosomename_roman_to_arabic()[0]:
                chrom = chromosomename_roman_to_arabic()[0].get(region[0])
        else:
            print(warningmessage)
            return()
        roi_start = region[1]
        roi_end = region[2]
        region_type = &#39;Chromosome&#39;


    elif type(region) == int:
        if region in chromosomename_roman_to_arabic()[0]:
            chrom = chromosomename_roman_to_arabic()[0].get(region)
            roi_start = None
            roi_end = None
        else:
            print(warningmessage)
            return()
        region_type = &#39;Chromosome&#39;


    else:
        print(warningmessage)
        return()
    
    return roi_start,roi_end,region_type,chrom</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.dna_features_helpers.intergenic_regions"><code class="name flex">
<span>def <span class="ident">intergenic_regions</span></span>(<span>chrom, start_chr, dna_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Getting intergenic regions from chromosome of interest </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chrom</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the chromosome in roman where to extract the information.</dd>
<dt><strong><code>start_chr</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt>2nd output of the gene_location function</dt>
<dt><strong><code>dna_dict</code></strong> :&ensp;<code>dict </code></dt>
<dd>1st output of the gene_location function</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dna_dict_new</code></strong> :&ensp;<code>dict</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>genomicregions_list</code></strong> :&ensp;<code>list</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intergenic_regions(chrom,start_chr,dna_dict):
    &#34;&#34;&#34;Getting intergenic regions from chromosome of interest 

    Parameters
    ----------
    chrom : str
        Name of the chromosome in roman where to extract the information.
    start_chr : int
       2nd output of the gene_location function 
    dna_dict : dict 
        1st output of the gene_location function 

    Returns
    -------
    dna_dict_new : dict
        
    genomicregions_list: list

    
    &#34;&#34;&#34;


    sgd_features_file=load_sgd_tab()
    ## GET FEATURES FROM INTERGENIC REGIONS 

    genomicregions_list = sgd_features(sgd_features_file)[0]

    i = 2
    for genomicregion in genomicregions_list[1:]:
        dna_dict_new = feature_position(sgd_features(sgd_features_file)[i], chrom, start_chr, dna_dict, genomicregion)
        i += 1
    
    return dna_dict_new,genomicregions_list</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.dna_features_helpers.read_pergene_file"><code class="name flex">
<span>def <span class="ident">read_pergene_file</span></span>(<span>pergene_insertions_file, chrom)</span>
</code></dt>
<dd>
<div class="desc"><p>Reading the pergene file , the information per gene , related to where it starts and ends in the genome. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pergene_insertions_file</code></strong> :&ensp;<code>str</code></dt>
<dd>absolute path of the per gene file location</dd>
<dt><strong><code>chrom</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the chromosome in roman where to extract the informatiion from the wigfile</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>gene_position_dict</code></strong> :&ensp;<code>dict </code></dt>
<dd>A dictionary describing the chromosome, start, and end location of every gene in the chromosome of interest.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_pergene_file(pergene_insertions_file,chrom):
    &#34;&#34;&#34;Reading the pergene file , the information per gene , related to where it starts and ends in the genome. 

    Parameters
    ----------
    pergene_insertions_file : str
        absolute path of the per gene file location
    chrom : str
        Name of the chromosome in roman where to extract the informatiion from the wigfile

    Returns
    -------
    gene_position_dict : dict 
        A dictionary describing the chromosome, start, and end location of every gene in the chromosome of interest. 
    &#34;&#34;&#34;

    with open(pergene_insertions_file) as f:
        lines = f.readlines()


    gene_position_dict = {}
    for line in lines[1:]:
        line_split = line.strip(&#39;\n&#39;).split(&#39;\t&#39;)


        if line_split[1] == chrom:
            genename = line_split[0]
            gene_chrom = line_split[1]
            gene_start = int(line_split[2])
            gene_end = int(line_split[3])

            gene_position_dict[genename] = [gene_chrom, gene_start, gene_end] #DICT CONTAINING ALL GENES WITHIN THE DEFINED CHROMOSOME INCLUDING ITS START AND END POSITION


            geneinserts_str = line_split[4].strip(&#39;[]&#39;)
            if not geneinserts_str == &#39;&#39;:
                geneinserts_list = [int(ins) for ins in geneinserts_str.split(&#39;,&#39;)]
            else:
                geneinserts_list = []


            genereads_str = line_split[5].strip(&#39;[]&#39;)
            if not genereads_str == &#39;&#39;:
                genereads_list = [int(read) for read in genereads_str.split(&#39;,&#39;)]
            else:
                genereads_list = []


            if len(geneinserts_list) != len(genereads_list):
                print(&#39;WARNING: %s has different number of reads compared with the number of inserts&#39; % genename )

    return gene_position_dict</code></pre>
</details>
</dd>
<dt id="transposonmapper.processing.dna_features_helpers.read_wig_file"><code class="name flex">
<span>def <span class="ident">read_wig_file</span></span>(<span>wig_file, chrom)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the information in the wigfile related to the chromosome of interested</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wig_file</code></strong> :&ensp;<code>str</code></dt>
<dd>absolute path of the wigfile location</dd>
<dt><strong><code>chrom</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the chromosome in roman where to extract the informatiion from the wigfile</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>insrt_in_chrom_list</code></strong> :&ensp;<code>list </code></dt>
<dd>Genomic locations of transposon insertions in the given chromosome.</dd>
<dt><strong><code>reads_in_chrom_list</code></strong> :&ensp;<code>list</code></dt>
<dd>How many reads are in each of the genomic locations of the insertions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_wig_file(wig_file,chrom):
    &#34;&#34;&#34;Extract the information in the wigfile related to the chromosome of interested

    Parameters
    ----------
    wig_file : str
        absolute path of the wigfile location
    chrom : str
        Name of the chromosome in roman where to extract the informatiion from the wigfile

    Returns
    -------
    insrt_in_chrom_list : list 
        Genomic locations of transposon insertions in the given chromosome.
    reads_in_chrom_list: list
        How many reads are in each of the genomic locations of the insertions. 
    
    &#34;&#34;&#34;

    with open(wig_file, &#39;r&#39;) as f:
        lines = f.readlines()

    chrom_start_line_dict, chrom_end_line_dict = chromosome_name_wigfile(lines)[1:]

    insrt_in_chrom_list = []
    reads_in_chrom_list = []
    for l in lines[chrom_start_line_dict.get(chrom):chrom_end_line_dict.get(chrom)]:
        insrt_in_chrom_list.append(int(l.strip(&#39;\n&#39;).split(&#39; &#39;)[0]))
        reads_in_chrom_list.append(int(l.strip(&#39;\n&#39;).split(&#39; &#39;)[1]))
        
    return insrt_in_chrom_list,reads_in_chrom_list</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="transposonmapper.processing" href="index.html">transposonmapper.processing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="transposonmapper.processing.dna_features_helpers.build_dataframe" href="#transposonmapper.processing.dna_features_helpers.build_dataframe">build_dataframe</a></code></li>
<li><code><a title="transposonmapper.processing.dna_features_helpers.checking_features" href="#transposonmapper.processing.dna_features_helpers.checking_features">checking_features</a></code></li>
<li><code><a title="transposonmapper.processing.dna_features_helpers.feature_position" href="#transposonmapper.processing.dna_features_helpers.feature_position">feature_position</a></code></li>
<li><code><a title="transposonmapper.processing.dna_features_helpers.gene_location" href="#transposonmapper.processing.dna_features_helpers.gene_location">gene_location</a></code></li>
<li><code><a title="transposonmapper.processing.dna_features_helpers.input_region" href="#transposonmapper.processing.dna_features_helpers.input_region">input_region</a></code></li>
<li><code><a title="transposonmapper.processing.dna_features_helpers.intergenic_regions" href="#transposonmapper.processing.dna_features_helpers.intergenic_regions">intergenic_regions</a></code></li>
<li><code><a title="transposonmapper.processing.dna_features_helpers.read_pergene_file" href="#transposonmapper.processing.dna_features_helpers.read_pergene_file">read_pergene_file</a></code></li>
<li><code><a title="transposonmapper.processing.dna_features_helpers.read_wig_file" href="#transposonmapper.processing.dna_features_helpers.read_wig_file">read_wig_file</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>